(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{412:function(t,_,v){"use strict";v.r(_);var e=v(40),a=Object(e.a)({},function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("div",{staticClass:"tip custom-block"},[v("p",[t._v("本来是想中秋节来写这篇博客的，但是中秋节又要睡觉，又要打牌，又要玩手机，又要刷 B 站。很忙，没时间搞学习。一来二去，还是确定要让自己舍弃 B 站和麻将，早就想到会上瘾，手机上才一直不敢安装，没想到在电脑上也能玩个不亦乐乎。这几天就利用一下在公司的时间把博客写一下吧，只有这样了。")])]),t._v(" "),v("p",[t._v("这篇博客呢是记录我这个月学习《图解 HTTP》的情况的，原计划是一个月把这本书读完，搞来搞去现在只剩半个月了，真是相当惭愧。为什么要写博客主要是因为想证明一下自己确实看过，正好之前有几节 HTTP 深入浅出的课没有看完，想着干脆借着这次看书的机会把这几节课也一块刷完。")]),v("div",{staticStyle:{"text-align":"center"}},[v("img",{attrs:{src:"20190917A/timg.jpg",alt:"麻将"}})]),v("p"),t._v(" "),v("h2",{attrs:{id:"_1、http-协议是什么，有哪些特点？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、http-协议是什么，有哪些特点？","aria-hidden":"true"}},[t._v("#")]),t._v(" 1、HTTP 协议是什么，有哪些特点？")]),t._v(" "),v("p",[t._v("之前在找工作的时候就遇到一些有关 HTTP 的面试题，那时候在博客里面这样归纳过 HTTP：")]),t._v(" "),v("blockquote",[v("p",[t._v("HTTP 是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是应用层的协议，也是一种无状态、无连接的应用层协议。")])]),t._v(" "),v("p",[t._v("这句话说得不是很浅显。用通俗些的话来说，实际上，从浏览器输入 URL 开始，到 Web 页面呈现出来为止，大概就是客户端发送请求，Web 服务器将相应的文件资源传输给客户端的过程。这一系列的操作就是以 HTTP 协议作为规范而建立的，可以这么理解 HTTP 就是传输信息所需要遵循的规则。")]),t._v(" "),v("p",[t._v("HTTP 的初期版本 HTTP 1.0 早在 1996 年就诞生了，至今仍在被广泛应用在服务器端。此后在 1997 年公布的 HTTP 1.1 是目前主流的 HTTP 协议版本。此后的新版本 HTTP 2.0 相比于 HTTP 1.X，可以说是大幅度提高了 web 的性能，但是目前还没有较高的覆盖率。可见，HTTP 作为文档传输协议，版本更新非常少。至于这几个版本的区别，以及它们相应的特点，可以参阅我之前写的博客，里面讲的还算详尽："),v("a",{attrs:{href:"/1903/20190321A"}},[t._v("【归纳】HTTP 协议的发展历程")]),t._v("。")]),t._v(" "),v("h2",{attrs:{id:"_2、uri-和-url-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、uri-和-url-的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" 2、URI 和 URL 的区别")]),t._v(" "),v("p",[t._v("比起 URI，URL 似乎更加广为人知。URL（Uniform Resource Locator）也叫统一资源定位符，正是使用 Web 浏览器访问 Web 页面时需要输入的网页地址。例如："),v("code",[t._v("https://franko.top/")]),t._v("就是 URL。")]),t._v(" "),v("p",[t._v("URI 是 Uniform Resource Identifier 的缩写，也叫统一资源表示符。因为互联网上的资源不止有网页，URI 采用各种协议访问互联网上的各类资源。采用 HTTP 协议时，协议方案就是 http，此外还有 ftp、mailto、telnet、file 等。例如，"),v("code",[t._v("mailto:John.Doe@example.com")]),t._v("、"),v("code",[t._v("news:comp.infosystems.www.servers.unix")]),t._v("、"),v("code",[t._v("tel:+1-816-555-1212")]),t._v("、"),v("code",[t._v("telnet://192.0.2.16:80/")]),t._v("这些都是 URI。")]),t._v(" "),v("p",[t._v("URI 用字符串标识某一互联网资源，而 URL 用于表示资源的地点（在互联网上所处的位置）。URI 的范围比 URL 宽泛，不止能表示网页，可见 URL 是 URI 的子集。")]),t._v(" "),v("h2",{attrs:{id:"_3、osi-七层模型、tcp-ip-四层模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、osi-七层模型、tcp-ip-四层模型","aria-hidden":"true"}},[t._v("#")]),t._v(" 3、OSI 七层模型、TCP/IP 四层模型")]),t._v(" "),v("p",[t._v("OSI 模型是由 ISO(国际标准化组织）制定的，它有三个基本的功能：提供给开发者一个必须的、通用的概念以便开发完善、可以用来解释连接不同系统的框架。OSI将计算机网络体系结构(architecture）划分为以下七层：")]),t._v(" "),v("ul",[v("li",[t._v("应用层")]),t._v(" "),v("li",[t._v("表示层")]),t._v(" "),v("li",[t._v("会话层")]),t._v(" "),v("li",[t._v("传输层")]),t._v(" "),v("li",[t._v("网络层")]),t._v(" "),v("li",[t._v("数据链路层")]),t._v(" "),v("li",[t._v("物理层")])]),t._v(" "),v("p",[t._v("OSI参考模型并没有提供一个可以实现的方法，而是描述了一些概念，用来协调进程间通信标准的制定。目前已被主流的 TCP/IP 四层模型取代。TCP/IP协议在一定程度上参考了OSI的体系结构，将七层模型简化成了四层：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("应用层")]),t._v("：应用层决定了向用户提供应用服务时通信的活动。HTTP 协议、FTP 协议、DNS 系统都处于该层，可见应用层确定了传输的「规矩」")]),t._v(" "),v("li",[v("strong",[t._v("传输层")]),t._v("：传输层为应用层提供处于网络连接中的端到端的数据传输，确保信息的正确传输。TCP 与 UDP 协议都是在传输层")]),t._v(" "),v("li",[v("strong",[t._v("网络层")]),t._v("：网络层用来处理网络上流动的数据包，该层可以通过处理数据包往其中加入数据的传递路径")]),t._v(" "),v("li",[v("strong",[t._v("数据链路层")]),t._v("：用来处理链接网络的硬件部分，硬件上的范畴均在数据链路层的作用范围之内，该层负责将数据编译成上层可以理解的内容")])]),t._v(" "),v("p",[t._v("直接堆文字理解这四个层并不那么直观。借助这幅书里的图片加深一下 TCP/IP 协议族在各层的传输过程吧：")]),v("div",{staticStyle:{"text-align":"center"}},[v("img",{attrs:{src:"20190917A/1.jpg",alt:"四层模型"}})]),v("p"),t._v(" "),v("p",[t._v("在发送端，信息是从应用层发出，往下层传递；在接收端，信息则是往应用层去。如图所示，发送端在应用层根据 HTTP 协议发送请求，传输层再根据 TCP 协议将数据进行分隔，在报文中标记序号和端口号，接着网络层将作为通信地址的 MAC 地址加入数据中之后，将数据传输给应用层。服务器在链路层接收到数据，再依次向上层传输，直到传输到应用层，服务器才算真正接受到了客户端发来的请求。")]),t._v(" "),v("h2",{attrs:{id:"_4、tcp-协议的三次握手和四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4、tcp-协议的三次握手和四次挥手","aria-hidden":"true"}},[t._v("#")]),t._v(" 4、TCP 协议的三次握手和四次挥手")]),t._v(" "),v("p",[t._v("在前文的 TCP/IP 协议族中提到过 TCP 协议，TCP 协议也被称为"),v("strong",[t._v("传输控制协议")]),t._v("，位于传输层，提供可靠的数据传输服务。与之对应的是UDP（User Datagram Protocol ，用户数据报协议），是不可靠的传输层协议。")]),t._v(" "),v("p",[t._v("TCP 的可靠之处在于，为了准确无误地将数据传递给对方，在客户端与服务器建立连接时，TCP 协议采用了「三次握手」的策略。在使用 TCP 协议发送数据包之后，客户端会向服务器确认消息是否成功送达，过程如图所示，来捋一捋整个步骤：")]),v("div",{staticStyle:{"text-align":"center"}},[v("img",{attrs:{src:"20190917A/2.jpg",alt:"三次握手"}})]),v("p"),t._v(" "),v("ol",[v("li",[t._v("首先客户端发送四个带有 SYN 标志的数据包给对方，并设置序列号 seq 为 x，进入 SYN_SEND 状态")]),t._v(" "),v("li",[t._v("服务器接受到之后，回传一个带有 SYN/ACK 标志的数据包给对方，传达确认信息，并进入 SYN_RECV 状态。数据包设置序列号 ack 为 x + 1，代表此次是回应之前序列号为 x 的数据包，因为这次握手同样也是一次询问，所以设置序列号 seq 为 y。")]),t._v(" "),v("li",[t._v("客户端收到这条报文之后，回应一个带 ACK 标志的数据包，代表握手结束，进入 Established 状态。数据包序列表 seq 设置为 x + 1,ack 设置为 y + 1，代表此次是回应上次握手的数据")])]),t._v(" "),v("p",[t._v("如果在握手过程中某个阶段出现了中断，TCP 协议会再次以相同的顺序重新发送数据包，以保证通信的可靠性。")]),t._v(" "),v("p",[t._v("同样地，TCP 协议下客户端与服务器之间关闭连接则需要「四次挥手」，这也被称为 TCP 释放连接的过程。步骤大致如下所示：")]),v("div",{staticStyle:{"text-align":"center"}},[v("img",{attrs:{src:"20190917A/3.jpg",alt:"四次握手"}})]),v("p"),t._v(" "),v("ol",[v("li",[t._v("客户端发送一个 FIN ，告诉服务器想关闭连接。序列号 seq 设置为 u。")]),t._v(" "),v("li",[t._v("服务器收到这个 FIN ，发回一个 ACK。序列号 seq 设置为 v，ack 为 u + 1，表示回应上一步握手。")]),t._v(" "),v("li",[t._v("服务器通知应用程序关闭网络连接，应用程序关闭后需要通知客户端，因此发送一个 FIN 给客户端。序列号 seq 设置为 w，ack 仍为 u + 1，表示此次握手还是对第一步的回应，服务器已经关闭了应用程序。")]),t._v(" "),v("li",[t._v("客户端着手关闭，连接发回 ACK 报文确认。服务器收到数据后关闭连接。序列号 seq 设置为 u + 1，ack 为 w + 1。")])]),t._v(" "),v("p",[t._v("上面的这些标志是属于 TCP 协议下报文的一部分，大致具有如下含义：")]),t._v(" "),v("ul",[v("li",[t._v("ACK：TCP协议规定，只有 ACK = 1 时有效，也规定连接建立后所有发送的报文的ACK必须为 1。")]),t._v(" "),v("li",[t._v("SYN(SYNchronization)：在连接建立时用来同步序号。当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。")]),t._v(" "),v("li",[t._v("FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。")])]),t._v(" "),v("h3",{attrs:{id:"为什么建立连接时三次握手，关闭却要四步？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么建立连接时三次握手，关闭却要四步？","aria-hidden":"true"}},[t._v("#")]),t._v(" 为什么建立连接时三次握手，关闭却要四步？")]),t._v(" "),v("p",[t._v("这是因为服务端的 LISTEN 状态下的 SOCKET 当收到客户端建立连接请求的SYN 报文后，它可以把 ACK 和 SYN （ ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。")]),t._v(" "),v("p",[t._v("但关闭连接时，当服务器收到客户端的 FIN 报文通知时，服务器只能发一个回应报文ACK通知客户端已经收到，然后通知应用程序关闭。应用程序完成全部数据发送并确定可以终止了，服务器才能发送FIN告诉客户端可以真正断开连接了。所以这一步 ACK 报文和 FIN 报文需要分开发送，因此多了一个步骤。")]),t._v(" "),v("h3",{attrs:{id:"为什么建立连接时三次握手，而不是两步握手？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么建立连接时三次握手，而不是两步握手？","aria-hidden":"true"}},[t._v("#")]),t._v(" 为什么建立连接时三次握手，而不是两步握手？")]),t._v(" "),v("p",[t._v("为了实现可靠传输，发送方和接收方始终需要同步( SYNchronize )序号。 需要注意的是， 序号并不是从 0 开始的， 而是由发送方随机选择的初始序列号 ( Initial Sequence Number, ISN )开始 。 由于 TCP 是一个双向通信协议， 通信双方都有能力发送信息， 并接收响应。 因此， 通信双方都需要随机产生一个初始的序列号， 并且把这个起始值告诉对方。这样发送方就可以知道哪些数据被接收到，哪些数据没被接收到， 需要重发。")]),t._v(" "),v("hr"),t._v(" "),v("p",[t._v("这篇博客其实写的内容不多，但是这些天都在摸鱼，搞到现在才写完，惭愧惭愧。之前说不打麻将结果还是摸了两把，不过赢了心情就没有那么坏了，果然上次是因为玩输了才会感觉不好。不过还是要控制一下自己，打牌还是打少一点。这周希望可以再争取出一篇博客。")]),v("div",{staticStyle:{"text-align":"center"}},[v("img",{attrs:{src:"20190917A/4.png",alt:"赢了就很爽"}})]),v("p")])},[],!1,null,null,null);_.default=a.exports}}]);