(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{414:function(a,e,t){"use strict";t.r(e);var r=t(40),s=Object(r.a)({},function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("div",{staticClass:"tip custom-block"},[t("p",[a._v("又度过了摸鱼的一周，这一周只看了关于 HTTP 缓存控制的内容。因为总想着早点去公司刷上班时长，但是要早点去公司的话就要早点睡觉，早点睡觉就没时间在宿舍看课程，在公司看的话总感觉早上没有那么有精神。这周还是试着晚上看些课程吧，看看效果如何。")])]),a._v(" "),t("p",[a._v("之前几节博客里面讲过，HTTP 协议就是用于客户端与服务器之间交流的协议。客户端请求数据。服务器给出响应。在平时的应用中，常常会有频繁地需要同一个资源放入时候，如果每次都需要重新执行一遍请求响应流程，是比较浪费带宽的。这时候就需要用到缓存了。顾名思义，缓存就是将这些下次可能需要用到的数据储存起来，下次客户端需要的时候就可以直接用。")]),t("div",{staticStyle:{"text-align":"center"}},[t("img",{attrs:{src:"https://s2.ax1x.com/2020/01/20/1iNKiV.jpg",alt:"封面"}})]),t("p"),a._v(" "),t("p",[a._v("那么 HTTP 缓存是如何控制的呢？因为有时并不是每次都要用缓存中的内容，资源也是会更新的。为此，HTTP 协议通过请求报文和响应报文中添加相应的首部字段，借此让客户端判断是否需要使用缓存中的内容。接下来就对与缓存控制相关的 HTTP 首部字段做一些介绍。")]),a._v(" "),t("h3",{attrs:{id:"_1、expires"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、expires","aria-hidden":"true"}},[a._v("#")]),a._v(" 1、Expires")]),a._v(" "),t("p",[a._v("Expires 是早在 HTTP/1.0 版本就有的缓存控制策略，用于设定缓存的有效时间。 Expires 的值对应一个GMT（格林尼治时间），比如"),t("code",[a._v("Sat, 12 Oct 2019 12:57:56 GMT")]),a._v("，这个时间就是设置的缓存到期时间。客户端接收到带有这个字段的响应报文时，直到这个时间点到来之前，每当需要再次请求这个 URI 下的资源时，都会选择使用缓存中的内容，而不会发起请求：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Expires: Fri, 11 Jun 2021 11:33:01 GMT\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("不过，使用 Expires 控制缓存也有许多不妥之处。因为也许在缓存的有效期到来之前，服务器端就对资源做了相应的更新，但是客户端仍然会因为 Expires 的作用继续使用缓存中的内容。而且，Expires 的时间是由服务器端设置的，自然是使用服务器端的时间，如果客户端上的时间与服务器的时间并不同步，那么 Expires 就不能够准确地把握缓存的有效期了。")]),a._v(" "),t("h3",{attrs:{id:"_2、pragma"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、pragma","aria-hidden":"true"}},[a._v("#")]),a._v(" 2、Pragma")]),a._v(" "),t("p",[a._v("Pragma 是一个在 HTTP/1.0 中规定的通用首部，当服务器将在响应报文中的这个字段的值设置为"),t("code",[a._v("no-cache")]),a._v("后，客户端再次对此 URI 进行请求时，就不会直接读取本地缓存中的内容。一般用来向后兼容只支持 HTTP/1.0 协议的缓存服务器，那时候 HTTP/1.1 协议中的 Cache-Control 还没有出来：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Pragma: no-cache\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("需要注意的是，由于 Pragma 在 HTTP 响应中的行为没有确切规范，所以不能可靠替代 HTTP/1.1 中通用首部 Cache-Control，尽管在请求中，假如 Cache-Control 不存在的话，它的行为与 "),t("code",[a._v("Cache-Control: no-cache")]),a._v(" 一致。建议只在需要兼容 HTTP/1.0 客户端的场合下应用 Pragma 首部。")]),a._v(" "),t("h3",{attrs:{id:"_3、cache-control"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、cache-control","aria-hidden":"true"}},[a._v("#")]),a._v(" 3、Cache-Control")]),a._v(" "),t("p",[a._v("对于之前提到过的 Expires 的缓存内容到期时间控制不准确的问题。在 HTTP/1.1 中新增了 Cache-Control 字段。服务器端在相应报文首部加入 Cache-Control 字段，并设置 max-age 值，就可以设置缓存的有效时间：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Cache-Control: max-age=3600\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("上面的例子中，就设定了缓存的有效时间为 3600 秒。与 Expires 不同，Cache-Control 设置的有效期是相对于请求发起的时间而言的，因此不会出现服务器与客户端时间不一致的问题。在后续的 3600 秒内，客户端不会再重新访问该 URI 请求资源。需要注意的是，若报文中同时出现了 Expires 和 Cache-Control，则以 Cache-Control 为准。")]),a._v(" "),t("p",[a._v("此外，还可以设置 Cache-Control 的值为 no-cache，使得客户端不使用缓存中的内容，作用于之前提到的 Pragma 是一样的。"),t("code",[a._v("Cache-Control: no-cache")]),a._v(" 与 Pragma 与 max-age 不能搭配使用，这样会优先执行不使用缓存内容的效果，每次都会重新发请求，设置的有效期也就没有意义了。")]),a._v(" "),t("p",[a._v("Cache-Control 通用消息头字段，被用于在 http 请求和响应中，通过指定指令来实现缓存机制。不止在响应头中可以设置，客户端在请求头中也可以通过设置相应的值，来控制服务器端与缓存相关的行为，这里就不深挖了。这两张图片概括的还是不错的，分别是 Cache-Control 作为请求头或响应头对应的值的含义：")]),t("div",{staticStyle:{"text-align":"center"}},[t("img",{attrs:{src:"https://s2.ax1x.com/2020/01/20/1iNeZn.png",alt:"请求头"}})]),t("div",{staticStyle:{"text-align":"center"}},[t("img",{attrs:{src:"https://s2.ax1x.com/2020/01/20/1iNnI0.png",alt:"响应头"}})]),t("p"),a._v(" "),t("h3",{attrs:{id:"_4、last-modified"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、last-modified","aria-hidden":"true"}},[a._v("#")]),a._v(" 4、Last-Modified")]),a._v(" "),t("p",[a._v("上面的几种缓存方案并不能说是完美，因为缓存的有效期不并能够代表资源的有效期。有时资源并没有更新，但是缓存到期了；或者是资源已经更新，但是缓存到期了。如果能够通过判断资源是否改变，再来决定是否需要读取缓存中的内容，就更加稳妥了。因此，在 HTTP/1.1 中引入了「缓存校验」的概念，前面讲的都是「缓存控制」字段，接下来就讲的就是「缓存校验」字段了。")]),a._v(" "),t("p",[a._v("「缓存校验」的流程大概是这样的，客户端并仍然会向服务器发送请求，服务器通过请求头中带的字段决定客户端缓存中的数据是否需要更新，如果可以直接使用缓存，服务器就不会返回响应主体，而是返回一个 304 状态的响应报文。客户端收到响应之后，就选择使用缓存中的内容了。这样就大大减少了报文的体积，也提高了缓存的复用率。")]),a._v(" "),t("p",[a._v("Last-Modified 响应头就是用来完成这个任务的。服务器将资源从属给客户端时，在响应头中带上这个字段传输给客户端。Last-Modified 的值是此资源做出修改的日期及时间。客户端收到带有这个响应头的数据之后，在下次请求的时候，就会在请求头中加入 If-Modified-Since 字段，值设置为服务器之前传来的修改时间。服务器收到请求之后在借此进行比对，从而决定是否需要使用缓存:")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT // 响应头\n\nIf-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT // 请求头\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br")])]),t("h3",{attrs:{id:"_5、etag"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、etag","aria-hidden":"true"}},[a._v("#")]),a._v(" 5、ETag")]),a._v(" "),t("p",[a._v("了解了 Last-Modified 之后，还是可以发现一些问题。有时会出现这种情况，如果我对文件并没有修改，但还是会造成修改时间发生改变，这样的话 Last-Modified 就没法判断，造成缓存不能服用。为此，HTTP/1.1 推出了 ETag 实体首部字段，服务器通过特殊的算法，为资源生成一串「标识符」。类似于指纹，相同的文件的「标识符」是唯一的，文件发生改变后，标识符也会改变。借此就可以进行相应的缓存校验。")]),a._v(" "),t("p",[a._v("与 Last-Modified 相似，服务器将资源从属给客户端时，在响应头中带上这个字段传输给客户端。客户端收到带有这个响应头的数据之后，在下次请求的时候，就会在请求头中加入 If-None-Match 字段，值设置为服务器之前传来的修改时间。服务器收到请求之后在借此进行比对，从而决定是否需要使用缓存：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4" // 响应头\n\nIf-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4" // 请求头\n')])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br")])]),t("p",[a._v("由于 Last-Modified 精确度比 ETag 要低，所以 ETag 比 Last-Modified 更为常用，Last-Modified 只是一个备用机制。")]),a._v(" "),t("h3",{attrs:{id:"_6、结合使用做缓存控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6、结合使用做缓存控制","aria-hidden":"true"}},[a._v("#")]),a._v(" 6、结合使用做缓存控制")]),a._v(" "),t("p",[a._v("事实上，如果单独只在请求的时候做缓存校验，而不进行缓存控制，也是没有意义的。因为在默认情况下，客户端都会直接使用缓存中存放的数据，就走不到向服务器缓存校验这一步了。所以一半在做缓存校验的同时，也会同时为响应的资源设置缓存的有效时间，或者是直接使用 no-cache 或 Pragma 阻止客户端直接读取缓存内容。")]),a._v(" "),t("p",[a._v("为什么使用 no-cache 或 Pragma 禁用本地缓存，再向服务器缓存校验通过之后还是可以读取本地缓存中的内容呢？因为服务器返回的是 304 报文，这时缓存中的内容会被当作报文的响应主体供客户端读取，这样看起来就不是使用本地缓存中的内容了。")]),a._v(" "),t("p",[a._v("在实际工作中，常常会见到代码在编译后会出现带有乱码的文件名，事实上这也是一种缓存控制策略。每次文件更新之后文件名都做出改变，这样就绝对不会使用缓存中的数据；只要会使用缓存中的数据，那么数据肯定就没有过期。当然这种方法就不是在 HTTP 层面来控制缓存了。")]),a._v(" "),t("hr"),a._v(" "),t("p",[a._v("今天终于还是把博客给肝出来了，花了一个星期才看完的内容，硬是在周天凌晨才能把博客写完，也算是最后的倔强了。虽然内容比较水，但也应该不至于没有可取之处，至少在此之前从来都没有这样理解过这个知识点，都是死记硬背。再立一个 flag，下周还是要出一篇博客，还有就是少划一些水了。明天还要值班，该睡觉了。")]),t("div",{staticStyle:{"text-align":"center"}},[t("img",{attrs:{src:"https://s2.ax1x.com/2020/01/20/1iNMGT.jpg",alt:"Flag"}})]),t("p"),a._v(" "),t("p",[a._v("以下是本篇博客中给我启发的内容，在此鸣谢：")]),a._v(" "),t("ol",[t("li",[t("a",{attrs:{href:"https://imweb.io/topic/5795dcb6fb312541492eda8c",target:"_blank",rel:"noopener noreferrer"}},[a._v("HTTP缓存控制小结 - 腾讯Web前端 IMWeb 团队社区 | blog | 团队博客"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified",target:"_blank",rel:"noopener noreferrer"}},[a._v("Last-Modified - HTTP | MDN"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control",target:"_blank",rel:"noopener noreferrer"}},[a._v("Cache-Control - HTTP | MDN"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag",target:"_blank",rel:"noopener noreferrer"}},[a._v("ETag - HTTP | MDN"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Pragma",target:"_blank",rel:"noopener noreferrer"}},[a._v("Pragma - HTTP | MDN"),t("OutboundLink")],1)])])])},[],!1,null,null,null);e.default=s.exports}}]);