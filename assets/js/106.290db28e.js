(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{416:function(e,t,o){"use strict";o.r(t);var n=o(40),i=Object(n.a)({},function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("div",{staticClass:"tip custom-block"},[o("p",[e._v("真就一个月没写博客了，摸一天鱼下来没有感觉，但是摸一个月感觉就很明显。啊，竟然摸了一个月鱼，这种感觉。当然这个月也并非我有意不写博客，是有冠冕堂皇的理由的：这个月双十一了，加班很多，导致没有时间去做其他事情。现在双十一大促也告一段落，没有那么忙了（马上双十二了），也该悄咪咪地更一篇了。")])]),e._v(" "),o("p",[e._v("在如今的各类网站，用户访问都是需要相应的账户的，这样服务器才能知道当前访问的是谁，只靠 url 来区分用户是不现实的。而如何验证用户的身份，确认其是否有访问的权限，这个过程就被称为鉴权。本篇博客将对几种常见的鉴权方式进行介绍。")]),o("div",{staticStyle:{"text-align":"center"}},[o("img",{attrs:{src:"https://s2.ax1x.com/2020/01/02/lYoiAP.jpg",alt:"鉴别"}})]),o("p"),e._v(" "),o("h2",{attrs:{id:"session-鉴权机制"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#session-鉴权机制","aria-hidden":"true"}},[e._v("#")]),e._v(" Session 鉴权机制")]),e._v(" "),o("p",[e._v("Session 鉴权机制是围绕着 "),o("strong",[e._v("Cookie")]),e._v(" 而展开的。大家都知道，Cookies 就是辨别用户身份而储存在用户本地终端（Client Side）上的数据。然而，单纯地使用 Cookie 存储信息是不够安全的，Cookie 可能被泄露，或者说连泄露都算不上，因为 Cookie 就是存放在客户端的本地文件里的，用户可以直接修改 Cookie 中的内容，也就是 Cookie 可以被伪造。")]),e._v(" "),o("p",[e._v("以用户注册账号为例。首先浏览器需要将用户的用户名和密码等信息通过 POST 请求传递给服务器，然后服务器校验该账户是否可注册，然后返回给客户端注册成功/失败的信息。如果该账号是可注册的，服务器就将用户的信息保存在数据库中。服务器不应存储铭文密码，这样数据库被入侵的话就会有风险，因此服务器需要对用户信息进行加密。")]),e._v(" "),o("p",[e._v("至于如何加密，这里提一种方法。首先服务器需要生成一个随机数，然后将「用户名 + 密码 + 随机数」组成的字符串，使用 SHA256 加密算法进行加密。SHA256 是"),o("strong",[e._v("安全散列算法")]),e._v("的一种。安全散列算法能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。而对于任意长度的消息，SHA256 都会产生一个 256bit 长的哈希值，作为消息摘要。若输入的消息不同，它们对应到不同字符串的机率很高，如果输入的信息相同，则一定会得到相同的信息摘要。")]),e._v(" "),o("p",[e._v("因此，对于每个账号，服务器只需要存储用户名、随机数、消息摘要这几条信息。用户需要登入时，服务器拿到浏览器传来的用户名和密码，带上之前存下的随机数，再使用 SHA256 计算出的新的消息摘要，与之前注册时得到的消息摘要进行比对，如果对比结果一致则说明密码正确。这样就保证了数据库中用户信息的安全性。")]),e._v(" "),o("p",[e._v("言归正传，Session 鉴权机制是利用服务器端的 Session 和浏览器端的 Cookie 来实现前后端的认证，由于 HTTP 请求时是无状态的，就单个请求而言，服务器并不知道这个客户端之前有没有请求过，这时就需要在服务器端创建一个 Session 对象，将同一个客户端的请求都维护在各自的 Session 中。Session 对象中包含一些账户信息，以及一串随机字符串 sid。用户登入成功时，服务器响应时将这个 sid 放入 Set-Cookie 字段给浏览器，这样浏览器就会在 Cookie 中放入 sid。在下次访问网站时，因为 Cookie 会在请求时自动带入请求头中，请求到达服务器端的时候，将 Cookie 中带上的 sid 与 Session 中存放的 sid进行对比，如果一致，服务器则返回之前登录后存储的用户信息，如果不一致则需要重新登录。整个流程如图所示：")]),o("div",{staticStyle:{"text-align":"center"}},[o("img",{attrs:{src:"https://s2.ax1x.com/2019/12/30/llVvZT.jpg",alt:"Session鉴权机制"}})]),o("p"),e._v(" "),o("p",[e._v("当然，这种方法也是存在问题的。首先客户端必须是遵守 HTTP 协议的浏览器，因为只有浏览器才能操作 Cookie。这样原生平台（iOS, Android，Windows 8等）或者是小程序之类的就不行了，或者服务器发起请求模拟登录，它们都没有 Cookie。这样就导致了机制不够通用。此外，因为登录时要创建 Session 对象，若 Session 存在服务器内存中，内存不断消耗，增加负载，无法承载过多的用户，而且服务要做的事情比较繁琐。")]),e._v(" "),o("h2",{attrs:{id:"jwt-鉴权机制"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#jwt-鉴权机制","aria-hidden":"true"}},[e._v("#")]),e._v(" JWT 鉴权机制")]),e._v(" "),o("p",[e._v("JWT 是 "),o("strong",[e._v("JSON Web Token")]),e._v(" 的缩写，是为了在网络应用环境间传递声明（token）而执行的一种基于 JSON 的开放标准，可实现无状态、分布式的 Web 应用授权。JSON Web Token 一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。JWT 鉴权机制和 Session 鉴权机制的区别在于，JWT 鉴权机制无需把访问者信息存储在服务器端。前面提到，Session 鉴权机制有占用大量服务器内存的缺点，而 JWT 鉴权机制可以减轻服务端的内存压力。")]),e._v(" "),o("p",[e._v("还是以用户访问某个网站为例。首先用户发起登录网站的请求，传递用户名和密码给服务器。服务器拿到用户名和密码之后，再生成 token 字符串返回客户端。JSON Web Token 是由三部分（header、payload、signature）组成的，将这三部分链接一起就构成了 token 字符串:")]),e._v(" "),o("ul",[o("li",[e._v("header: token 的头部是声明鉴权机制和加密方式的 JSON 字符串，如 "),o("code",[e._v('{ "typ": "JWT", "alg": "SHA256" }')]),e._v("。然后使用base64 编码加密这串字符串，就得到了 token 的 header 部分。")]),e._v(" "),o("li",[e._v("playload：token 中的 playload（承载）用于存放有效信息，主要包含用户的一些信息、token相关信息（签发者、接收着、签发时间、过期时间等），格式也是 JSON 字符串，同样需要使用 base64 进行加密。")]),e._v(" "),o("li",[e._v("signature：token 中的 signature 也被称为签证信息，它会用到前面的 header、payload 信息，以及一个作为密匙（secret）的随机数。这个部分需要将这三段字符串使用"),o("code",[e._v(".")]),e._v("连接起来，并使用 header 中声明的加密方式（如上面声明的是 SHA256）对其进行加密，得到的结果即是 signature 部分。")])]),e._v(" "),o("p",[e._v("客户端获取到 token 之后，需要将 token 存储起来，在下次访问改网站发起请求时将 token 加入 Authorization 请求头中。客户端存储 token 并不依赖 Cookie，因此不一定要将 token 存在 Cookie 中，也可以存放在 LocalStorage 里。或者在 GET 请求时，直接将 token 放在 url 的请求参数中、POST 请求是放入请求体中，都是可以的。")]),e._v(" "),o("p",[e._v("服务器接收到 token 之后，就需要对其进行验证。首先服务器需要把 token 的三部分 header、payload、signature 分离出来，将 header、payload 与服务器存储的密匙（secret）重新生成一次 signature，对比与客户端传来的 token 中的 signature 是否一致。此外还需对 payload 进行解密得到 JSON 字符串，验证此 token 是否过期，确认 token 还在有效期内，才可以从数据库中取出用户的数据返回给客户端。JWT 鉴权的整体流程如图所示：")]),o("div",{staticStyle:{"text-align":"center"}},[o("img",{attrs:{src:"https://s2.ax1x.com/2020/01/02/lYya7Q.png",alt:"JWT 鉴权机制"}})]),o("p"),e._v(" "),o("p",[e._v("与 Session 机制相比，JWT 鉴权的优点很明显。JWT 鉴权机制在服务端不需要存储 session 信息，因为 Token 自身包含了所有登录用户的信息，只需要在客户端的 cookie 或本地介质存储状态信息，减少了服务器的负载。因为传输并不依赖 Cookie，所以在不支持 Cookie 的客户端中也可以使用。此外，Cookie 是不允许垮域访问的，这一点对 Token 机制是不存在的，前提是传输的 token 通过 HTTP 头传输。")]),e._v(" "),o("p",[e._v("当然，JWT 鉴权也有一些缺点。因为每次请求都要携带 token，服务器端每次都要解密和验证，增加了计算压力。还有就是 token 的有效性的问题，用户如果注销登录，但是这条 token 仍然有效，服务器如何判断存储中的未过期但无效的 token 信息？token 的有效性不宜过短也不宜过长，服务器还需要有为 token 续期的逻辑。此外，token 中的 payload 不适合存储敏感信息，而且服务器仍然需要存储一些数据，如密匙（secret）等。")]),e._v(" "),o("h2",{attrs:{id:"oauth2-0-协议"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#oauth2-0-协议","aria-hidden":"true"}},[e._v("#")]),e._v(" OAuth2.0 协议")]),e._v(" "),o("p",[e._v("OAuth（Open Authorization，开放授权）是为用户资源的授权定义了一个安全、开放及简单的标准，第三方无需知道用户的账号及密码，就可获取到用户的授权信息。在平时访问各种网站的时候可以发现，许多网站都支持第三方登录。用户如果使用第三方登录的话，往往就不用再自己注册账号了。用户连账户和密码都不用输入，那又如何进行鉴权呢？这就是本节将要提到的 OAuth2.0 协议。")]),e._v(" "),o("p",[e._v("这里以大家搭建博客网站最常用的支持 GitHub 登录为例。以前这个博客有评论功能的时候，就是可以使用 GitHub 登录的，当时觉得真的好厉害，现在理解了原理感觉也平易近人了许多。在整个认证和授权的过程中涉及的几方包括：GitHUb、用户、博客网站。简单来说，三方交涉的过程分为这几步：")]),e._v(" "),o("ol",[o("li",[e._v("博客网站需要先在 GitHub 生成应用，创建 "),o("strong",[e._v("Client Id")]),e._v("（名片）和 "),o("strong",[e._v("Client Secret")]),e._v("（密钥）；")]),e._v(" "),o("li",[e._v("用户登录博客网站，博客网站将 clientId 给用户，跳转到 GitHub 的认证页面；")]),e._v(" "),o("li",[e._v("用户使用 clientId 请求凭据，在 GitHub 的认证服务器确认允许后，给予用户一串带有允许凭据"),o("strong",[e._v("code")]),e._v("的 url，如"),o("code",[e._v("http://my-website.com?code=xxx")]),e._v("，并以此重定向会博客网站；")]),e._v(" "),o("li",[e._v("用户将凭据传递给博客网站，网站将 "),o("strong",[e._v("Client Id + Client Secret + code凭据")]),e._v("带给 GitHub 的认证服务器，请求"),o("strong",[e._v("access_token")]),e._v("（通行令牌）；")]),e._v(" "),o("li",[e._v("博客网站获取到 access_token 之后向 GitHub 请求该用户的数据， GitHub 确认令牌之后，将信息数据提供博客网站。")])]),e._v(" "),o("p",[e._v("上面这几步写得比较简略，下面这张图比较详细地描述了整个过程：")]),o("div",{staticStyle:{"text-align":"center"}},[o("img",{attrs:{src:"https://s2.ax1x.com/2020/01/02/ltievd.jpg",alt:"OAuth2.0 协议"}})]),o("p"),e._v(" "),o("p",[e._v("过程中涉及到两个凭证，一个是允许凭据 code，表明博客网站已经经过用户允许，可以获取 GitHub 中的信息；另一个是通行令牌 access_token，表明 GitHub 的认证服务器已经验明博客网站的身份。需要注意的是，access_token 是有过期时间的，在有效期内，网站可以使用这个 access_token 请求用户的数据，有效期过后，网站则需要使用 refresh_token 重新向认证服务器请求新的令牌，这个 refresh_token 也是由认证服务器和之前的 access_token 一起返回的。")]),e._v(" "),o("p",[e._v("使用 OAuth2.0 协议做用户的认证与授权的好处显而易见，很多网站、APP b并没有自己的账号体系，如果支持第三方帐号登录得话，这样不仅免去了用户注册账号的麻烦、还可以获取用户的好友关系来增强自身的社交功能。而且，认证服务器包办了各种复杂的鉴权逻辑，并处理敏感的用户凭据。OAuth 令牌提供了一种比密码略复杂的机制，但如果使用得当，其安全性要比密码高很多,网站只需要保护好自身的客户端凭据和用户的令牌即可。")]),e._v(" "),o("hr"),e._v(" "),o("p",[e._v("以上就是本文中关于网站鉴权方式的全部内容。这篇博客从十一月开篇以来写了两个月，是我属实没有想到的。这两个月都在摸鱼，上班的时候忙，下班的时候也不想写，最后终于没有写博客的机会。到现在双十一和双十二都过去了，上班的时候也不忙了，摸鱼终于没有借口了，只有把之前的欠账慢慢补上。新的一年希望尽量摸少一点鱼了，都转正的人了，压力很大的。")]),o("div",{staticStyle:{"text-align":"center"}},[o("img",{attrs:{src:"https://s2.ax1x.com/2020/01/02/ltu8w4.jpg",alt:"压力"}})]),o("p"),e._v(" "),o("p",[e._v("以下内容对本文的编写带来了很大的帮助和启发，在此鸣谢：")]),e._v(" "),o("ol",[o("li",[o("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/58490770",target:"_blank",rel:"noopener noreferrer"}},[e._v("一张图弄懂Session鉴权原理 - 知乎"),o("OutboundLink")],1),e._v("；")]),e._v(" "),o("li",[o("a",{attrs:{href:"http://www.mamicode.com/info-detail-2363829.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("基于token的鉴权机制 — JWT介绍"),o("OutboundLink")],1),e._v("；")]),e._v(" "),o("li",[o("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/58491095",target:"_blank",rel:"noopener noreferrer"}},[e._v("一张图弄懂Auth2原理 - 知乎"),o("OutboundLink")],1),e._v("；")]),e._v(" "),o("li",[o("a",{attrs:{href:"https://www.barretlee.com/blog/2016/01/10/oauth2-introduce/",target:"_blank",rel:"noopener noreferrer"}},[e._v("简述 OAuth 2.0 的运作流程 | 小胡子哥的个人网站"),o("OutboundLink")],1),e._v(";")]),e._v(" "),o("li",[o("a",{attrs:{href:"https://book.douban.com/reading/74585643/",target:"_blank",rel:"noopener noreferrer"}},[e._v("《OAuth 2实战》试读：1.4　OAuth 2.0：优点、缺点和丑陋的方面"),o("OutboundLink")],1),e._v("。")])])])},[],!1,null,null,null);t.default=i.exports}}]);