(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{398:function(e,t,a){"use strict";a.r(t);var r=a(40),v=Object(r.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h4",{attrs:{id:"作用域链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域链","aria-hidden":"true"}},[e._v("#")]),e._v(" 作用域链")]),e._v(" "),a("p",[e._v("作用域链是函数被创建的作用域中对象的集合，每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链。作用域链可以保证对执行环境有权访问的所有变量和函数的有序访问。")]),e._v(" "),a("p",[e._v("作用域链的最前端始终是当前执行的代码所在环境的变量对象（如果该环境是函数，则将其活动对象作为变量对象），下一个变量对象来自包含环境（包含当前还行环境的环境），下一个变量对象来自包含环境的包含环境，依次往上，直到全局执行环境的变量对象。")]),e._v(" "),a("h4",{attrs:{id:"面向对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象","aria-hidden":"true"}},[e._v("#")]),e._v(" 面向对象")]),e._v(" "),a("p",[e._v("专注于由哪一个对象来解决这个问题，编程特点是出现了一个类，从类中拿到对象，由这个对象去解决具体问题。 面向对象的三大特征是继承、封装、多态。")]),e._v(" "),a("p",[e._v("面向对象程序设计的目的是在编程中促进更好的灵活性和可维护性，在大型软件工程中广为流行。凭借其对模块化的重视，面向对象的代码开发更简单，更容易理解，相比非模块化编程方法 1, 它能更直接地分析, 编码和理解复杂的情况和过程。")]),e._v(" "),a("h4",{attrs:{id:"node"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node","aria-hidden":"true"}},[e._v("#")]),e._v(" Node")]),e._v(" "),a("p",[e._v("Node.js是一个可以快速构建网络服务及应用的平台，是用JavaScript语言构建的服务平台，可用于后端建立服务器。简单的说node.js就是把浏览器的解释器封装起来作为服务器运行平台，用类似JavaScript的结构语法进行编程，在node.js上运行。")]),e._v(" "),a("pre",[a("code",[e._v("Node的优点和缺点\n")])]),e._v(" "),a("p",[e._v("因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求。与Node代理服务器交互的客户端代码是由JavaScript语言编写的，因此客户端和服务器端都用同一种语言编写。")]),e._v(" "),a("p",[e._v("缺点：由于Node单线程，如果长时间运行计算将导致CPU不能释放，使得后续I/O无法发起。（解决办法是分解大型运算为多个小任务，不阻塞I/O发起）")]),e._v(" "),a("h4",{attrs:{id:"http-缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存","aria-hidden":"true"}},[e._v("#")]),e._v(" HTTP 缓存")]),e._v(" "),a("pre",[a("code",[e._v("http缓存了解哪些？\n")])]),e._v(" "),a("p",[e._v("Http 的缓存一般应用广泛的是使用 HTTP 头信息控制缓存。HTTP 头信息控制缓存大致分为两种：强缓存和协商缓存。强缓存如果命中缓存不需要和服务器端发生交互，而协商缓存不管是否命中都要和服务器端发生交互，强制缓存的优先级高于协商缓存。")]),e._v(" "),a("p",[e._v("强缓存：可以理解为无须验证的缓存策略。对强缓存来说，响应头中有两个字段 Expires/Cache-Control 来表明规则。（设置缓存有效期限/缓存剩余有效时间）")]),e._v(" "),a("p",[e._v("协商缓存：缓存的资源到期了，并不意味着资源内容发生了改变，如果和服务器上的资源没有差异，实际上没有必要再次请求。客户端和服务器端通过某种验证机制验证当前请求资源是否可以使用缓存。")]),e._v(" "),a("p",[e._v("这时，利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。")]),e._v(" "),a("p",[e._v("Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。")]),e._v(" "),a("p",[e._v("浏览器第一次请求数据之后会将数据和响应头部的缓存标识存储起来。再次请求时会带上存储的头部字段，服务器端验证是否可用。如果返回 304 Not Modified，代表资源没有发生改变可以使用缓存的数据，获取新的过期时间。反之返回 200 就相当于重新请求了一遍资源并替换旧资源。")]),e._v(" "),a("p",[e._v("链接："),a("a",{attrs:{href:"https://github.com/huyaocode/webKnowledge/blob/master/%E7%BD%91%E7%BB%9C/%E7%BC%93%E5%AD%98.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("HTTP缓存"),a("OutboundLink")],1)]),e._v(" "),a("h4",{attrs:{id:"dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dom","aria-hidden":"true"}},[e._v("#")]),e._v(" DOM")]),e._v(" "),a("pre",[a("code",[e._v("    一、节点创建型API\n\n    1.1 createElement\n    1.2 createTextNode\n    1.3 cloneNode\n    1.4 createDocumentFragment\n\n    二、页面修改形API（包括删除和添加）（删）（改）\n\n    2.1 appendChild(追加为子元素)\n    2.2 insertBefore(插入前面)\n    2.3 removeChild(删除子元素)\n    2.4 replaceChild(替换子元素)\n\n    三 节点查询型API(查)\n\n    3.1 document.getElementById\n    3.2 document.getElementsByTagName\n    3.3 document.getElementsByName\n    3.4 document.getElementsByClassName\n    3.5 document.querySelector和document.querySelectorAll\n    3.6 elementFromPoint()\n")])]),e._v(" "),a("p",[e._v("innerText是文本内容，innerHTML、outerHTML（包括自身）返回html结构。")]),e._v(" "),a("h4",{attrs:{id:"mvc-与-mvvm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvc-与-mvvm","aria-hidden":"true"}},[e._v("#")]),e._v(" MVC 与 MVVM")]),e._v(" "),a("p",[e._v("Mvvm定义MVVM是Model-View-ViewModel的简写。即模型-视图-视图模型。【模型】指的是后端传递的数据。【视图】指的是所看到的页面。【视图模型】mvvm模式的核心，它是连接view和model的桥梁。")]),e._v(" "),a("p",[e._v("在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。")]),e._v(" "),a("p",[e._v("MVC是Model-View- Controller的简写。即模型-视图-控制器。M和V指的意思和MVVM中的M和V意思一样。C即Controller指的是页面业务逻辑。MVC和MVVM的区别并不是VM完全取代了C，ViewModel存在目的在于抽离Controller中展示的业务逻辑，而不是替代Controller，其它视图操作业务等还是应该放在Controller中实现。")]),e._v(" "),a("h4",{attrs:{id:"虚拟-dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom","aria-hidden":"true"}},[e._v("#")]),e._v(" 虚拟 DOM")]),e._v(" "),a("p",[e._v("虚拟DOM（virtual dom），是vue和react的核心，继react之后vue2.0也在其核心引入了虚拟DOM的概念。所谓的虚拟DOM实际上就是根据真实的DOM结构创建的与真实的DOM结构一一映射的数据结构。")]),e._v(" "),a("p",[e._v("要想做到虚拟DOM的部分更新，就需要区分出前后两个虚拟DOM结构中数据更新的内容，diff算法作为Virtual DOM的加速器，其算法的改进优化是React整个界面渲染的基础和性能的保障。React 三个策略：")]),e._v(" "),a("ul",[a("li",[e._v("Web UI 中DOM节点跨层级的移动操作特别少，可以忽略不计")]),e._v(" "),a("li",[e._v("拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。")]),e._v(" "),a("li",[e._v("对于同一层级的一组子节点，它们可以通过唯一id进行区分。")])]),e._v(" "),a("h4",{attrs:{id:"node-项目的思路"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node-项目的思路","aria-hidden":"true"}},[e._v("#")]),e._v(" node 项目的思路")]),e._v(" "),a("p",[e._v("本项目使用了 express-generator 来搭建 Express 应用框架。之所以使用 express，是因为 express 提供的模块能够把 node.js 的 http 功能封装到简单易用的接口中。")]),e._v(" "),a("p",[e._v("数据库这里使用的是 SQLite3。SQLite3 只是一个轻型的嵌入式数据库引擎，占用资源非常低，处理速度比 Mysql 还快，专门用于移动设备上进行适量的数据存取，它只是一个文件，不需要服务器进程，所有的数据库操作就相当于对这个本地的数据库文件的内容的增删改查。")]),e._v(" "),a("p",[e._v("页面的渲染是借助 ejs 模板引擎实现的，使用 ejs 模板文件，结合从数据库中获取到的相应的数据，然后借助模板引擎，就能生成HTML了。")]),e._v(" "),a("p",[e._v("至于页面的路由，是通过调用各种 express router 也就是路由管理中间件函数进行处理与配置的。当访问一个地址时，服务器要对这个路径做出响应，可以把这个过程看作一个路由。访问的“/”即为router路径，服务器采取的动作即为middleware，即一个个特殊的函数。")]),e._v(" "),a("p",[e._v("所谓中间件，就是在受到请求后和发送请求之前这个阶段执行的一些函数。中间件函数能够访问请求对象, 响应对象, 和next 的变量。中间件讲究顺序，匹配上第一个之后，需要调用next函数才能够继续往后匹配。（使用app.use方法插入中间件。）")]),e._v(" "),a("h4",{attrs:{id:"难题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#难题","aria-hidden":"true"}},[e._v("#")]),e._v(" 难题")]),e._v(" "),a("p",[e._v("我觉得我遇到的最大的问题就是，当前掌握的知识，就说说我最近几天在做一个小的demo吧，这个demo的目的是实现将中页面中许多点依次用线连接的动画，而且动画是需要支持继续、播放、暂停。这个demo的链接")]),e._v(" "),a("p",[e._v("为了实现这样的动画，我首先想到使用 CSS3 的 animation 以及 使用 JS 控制动画，但是想到运行过程控制较弱,无法附加事件绑定回调函数。CSS动画只能暂停,不能在动画中寻找一个特定的时间点，不能在半路反转动画，不能变换时间尺度，不能在特定的位置添加回调函数或是绑定回放事件；而JS动画虽然能够实现各种控制操作，但是代码的复杂度显得过高了。")]),e._v(" "),a("p",[e._v("因为我之前专门针对Canvas与SVG进行了学习，所以我最终在比较二者的区别之后，选择了SVG，因为SVG 使用XML文档来描述来绘图，更加适合做动态交互，编辑很容易，只需要增加或者移除相应的元素就可以了，而且在SVG中有一个专门用来定义动画的animate标签。但是我对这方面的知识并不熟悉，所以我在Google和MDN上寻找参考，不过在MDN上并没有找到SVG动画的控制方法，最后在张鑫旭的技术博客上才找到使用SVG animate的控制 API的方法，最后成功实现了这个demo，虽然效果上谈不上有多惊艳，bug我也任务这次碰到的问题也算是我学习前端过程的一个缩影吧。")]),e._v(" "),a("h4",{attrs:{id:"eventloop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#eventloop","aria-hidden":"true"}},[e._v("#")]),e._v(" eventloop")]),e._v(" "),a("ul",[a("li",[e._v("主线程运行的时候会生成堆（heap）和栈（stack）；")]),e._v(" "),a("li",[e._v("js从上到下解析方法，将其中的同步任务按照执行顺序排列到执行栈中；")]),e._v(" "),a("li",[e._v("当程序调用外部的API时，比如ajax、setTimeout等，会将此类异步任务挂起，继续执行执行栈中的任务，等异步任务返回结果后，再按照执行顺序排列到事件队列中；")]),e._v(" "),a("li",[e._v("主线程先将执行栈中的同步任务清空，然后检查事件队列中是否有任务，如果有，就将第一个事件对应的回调推到执行栈中执行，若在执行过程中遇到异步任务，则继续将这个异步任务排列到事件队列中。")]),e._v(" "),a("li",[e._v("主线程每次将执行栈清空后，就去事件队列中检查是否有任务，如果有，就每次取出一个推到执行栈中执行，这个过程是循环往复的... ...，这个过程被称为“Event Loop 事件循环”。")])]),e._v(" "),a("h4",{attrs:{id:"vue-3-0-与-typescript"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-0-与-typescript","aria-hidden":"true"}},[e._v("#")]),e._v(" Vue 3.0 与 TypeScript")]),e._v(" "),a("p",[e._v("VUE3.0 会兼容 VUE2.0 语法 和 API 帮助 2.0 用户平滑过渡到3.0，现在vue3.0也全面改用TypeScript来重写了。")]),e._v(" "),a("p",[e._v("TypeScript是一门支持ES6规范的语言。TypeScript 扩展了JavaScript语法，任何已经存在的JavaScript程序，可以不加任何改动，在TypeScript环境下运行。TypeScript只是向JavaScript添加了一些新的遵循ES6规范的语法，以及基于类的面向对象编程的这种特性。")]),e._v(" "),a("p",[e._v("第一个特性叫做类型检测，在Typescript里面是运行为变量指定类型的，比如当你为这个变量指定数字类型的值的时候，IDE会做出类型检查，然后告诉你这里可能会有错误，这个特性会减少你在开发阶段犯错误的几率。第二个特性是语法提示，在IDE里面去编写TypeScript的代码时，IDE会根据你当前的上下文，把你能用的类、变量、方法和关键字都给你提示出来，你只要直接去选就可以了，这个特性会大大提升你的开发效率。第三个特性是重构，重构是说你可以很方便的去修改你的变量或者方法的名字或者是文件的名字，当你做出这些修改的时候，IDE会帮你自动引用这个变量或者调用这个方法地方的代码自动帮你修改掉，这个特性一个是会提高你的开发效率，另一个是可以很容易的提升你的代码质量。")]),e._v(" "),a("h4",{attrs:{id:"排序算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#排序算法","aria-hidden":"true"}},[e._v("#")]),e._v(" 排序算法")]),e._v(" "),a("p",[e._v("几种排序的思路："),a("a",{attrs:{href:"http://franko.top/tags/#%E7%AE%97%E6%B3%95",target:"_blank",rel:"noopener noreferrer"}},[e._v("算法"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("稳定排序和不稳定排序: "),a("a",{attrs:{href:"https://blog.csdn.net/taotaoah/article/details/52745788",target:"_blank",rel:"noopener noreferrer"}},[e._v("详细内容"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法")]),e._v(" "),a("p",[e._v("而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法")]),e._v(" "),a("h4",{attrs:{id:"垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收","aria-hidden":"true"}},[e._v("#")]),e._v(" 垃圾回收")]),e._v(" "),a("p",[e._v("标记清除（mark and sweep）：")]),e._v(" "),a("pre",[a("code",[e._v("这是 JavaScript 最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”\n\n垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了\n")])]),e._v(" "),a("p",[e._v("引用计数(reference counting)：")]),e._v(" "),a("h4",{attrs:{id:"模块化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块化","aria-hidden":"true"}},[e._v("#")]),e._v(" 模块化")]),e._v(" "),a("p",[e._v("模块化可以给带来以下好处：解决命名冲突；提供复用性；提高代码可维护性")]),e._v(" "),a("p",[e._v("实现模块化方式：立即执行函数；AMD 和 CMD；CommonJS；ES Module")]),e._v(" "),a("p",[e._v("commonjs模块和es6模块最主要的区别：commonjs模块是拷贝，es6模块是引用，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。")]),e._v(" "),a("p",[e._v("CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 输出是值的拷贝，即原来模块中的值改变不会影响已经加载的该值，ES6静态分析，动态引用，输出的是值的引用，值改变，引用也改变，即原来模块中的值改变则该加载的值也改变。")]),e._v(" "),a("p",[e._v("CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。")]),e._v(" "),a("p",[e._v("CommonJS 加载的是整个模块，即将所有的接口全部加载进来，ES6 可以单独加载其中的某个接口（方法），")]),e._v(" "),a("p",[e._v("CommonJS this 指向当前模块，ES6 this 指向undefined")])])},[],!1,null,null,null);t.default=v.exports}}]);