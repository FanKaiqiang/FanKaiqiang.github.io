(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{357:function(t,a,e){"use strict";e.r(a);var r=e(40),s=Object(r.a)({},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("div",{staticClass:"tip custom-block"},[e("p",[t._v("今晚十点钟的时候开这篇博客，应该是开得比较晚了吧，自信自己今天可以比较快写完。毕竟今天内容不多嘛，而且刚才已经把比较重要的关于居中的部分整理完了。当然如果今天这篇写不完也是有可能的，可能会花一些时间用来查资料吧，今天写不完就算了。")])]),t._v(" "),e("p",[t._v("本篇博客的主题是关于CSS可能会问的面试题，就按照昨天的思路把几个重要的问题答一下。")]),e("div",{staticStyle:{"text-align":"center"}},[e("img",{attrs:{src:"20181118A/timg.jpg",alt:"面试"}})]),e("p"),t._v(" "),e("h2",{attrs:{id:"_1、说说盒模型（必考）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、说说盒模型（必考）","aria-hidden":"true"}},[t._v("#")]),t._v(" 1、说说盒模型（必考）")]),t._v(" "),e("p",[t._v("盒模型的四个组成结构：content（内容）、padding（内边距）、border（边框）、margin（外边距）")]),t._v(" "),e("p",[t._v("盒模型都具备这些属性。这些属性可以把它转移到日常生活中的盒子（箱子）上来理解，日常生活中所见的盒子也就是能装东西的一种箱子，也具有这些属性，所以叫它盒模型。")]),t._v(" "),e("p",[t._v("主要有两种盒模型，W3C盒模型是与IE盒模型。区别就是对宽高的定义不同。：")]),t._v(" "),e("p",[e("strong",[t._v("content-box(W3C盒模型)")]),t._v("：width = content(内容区宽度)")]),t._v(" "),e("p",[e("strong",[t._v("border-box(IE盒模型)")]),t._v("：width = content + padding-left + padding-right + border-left + border-right")]),t._v(" "),e("p",[t._v("默认使用标准的w3c盒子模型，如果需要使用IE的盒子模型，可以使用box-sizing属性进行修改："),e("code",[t._v("box-sizing:border-box")]),t._v("。")]),t._v(" "),e("h2",{attrs:{id:"_2、css-reset-和-normalize-css-有何区别？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、css-reset-和-normalize-css-有何区别？","aria-hidden":"true"}},[t._v("#")]),t._v(" 2、CSS reset 和 normalize.css 有何区别？")]),t._v(" "),e("p",[t._v("这道题其实是在考英文，因为reset就是重置的意思，normalize的意思则是标准化，区别已经很明显了。")]),t._v(" "),e("p",[t._v("CSS Reset，意为重置默认样式。HTML中绝大部分标签元素在网页显示中都有一个默认属性值，通常为了避免重复定义元素样式，需要进行重置默认样式（CSS Reset），即抛弃原有的默认样式。")]),t._v(" "),e("p",[e("a",{attrs:{href:"http://necolas.github.io/normalize.css/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Normalize.css"),e("OutboundLink")],1),t._v("是一种CSS reset的替代方案。Normalize.css能够让所有浏览器的标签都跟标准规定的默认样式一，使得页面在各浏览器上显示的标签的默认样式基本统一。相比于传统的CSS reset，Normalize.css是一种现代的、为HTML5准备的优质替代方案。")]),t._v(" "),e("h2",{attrs:{id:"_3、如何居中（必考）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、如何居中（必考）","aria-hidden":"true"}},[t._v("#")]),t._v(" 3、如何居中（必考）")]),t._v(" "),e("p",[t._v("这一点主要还是看平时的总结了，居中的方式挺多的。如果是水平居中的话：")]),t._v(" "),e("ul",[e("li",[t._v("内联元素：给父元素加text-align: center;")]),t._v(" "),e("li",[t._v("块级元素：margin: 0 auto;")])]),t._v(" "),e("p",[t._v("关于垂直居中我以前写过归纳的博客，那是两个月前刚开始学CSS的时候，现在也记得不清楚了，所以昨天重新把这篇博客整理了一遍："),e("a",{attrs:{href:"http://franko.top/1809/20180916A/",target:"_blank",rel:"noopener noreferrer"}},[t._v("【归纳】如何CSS实现各种布局"),e("OutboundLink")],1),t._v("，这回借助老师的直播课总算把这个问题搞清楚了。")]),t._v(" "),e("h2",{attrs:{id:"_4、选择器的优先级如何确定？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、选择器的优先级如何确定？","aria-hidden":"true"}},[t._v("#")]),t._v(" 4、选择器的优先级如何确定？")]),t._v(" "),e("h3",{attrs:{id:"_1-选择器的种类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-选择器的种类","aria-hidden":"true"}},[t._v("#")]),t._v(" (1) 选择器的种类")]),t._v(" "),e("p",[t._v("在谈到选择器的优先级之前顺便把选择器的种类在这里归纳一下，大概有如下几种：")]),t._v(" "),e("h4",{attrs:{id:"①-基础的选择器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#①-基础的选择器","aria-hidden":"true"}},[t._v("#")]),t._v(" ① 基础的选择器")]),t._v(" "),e("div",{staticStyle:{"text-align":"center"}},[t._v("![基础选择器](20181118A/001.png)")]),t._v(" "),e("h4",{attrs:{id:"②-组合选择器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#②-组合选择器","aria-hidden":"true"}},[t._v("#")]),t._v(" ② 组合选择器")]),t._v(" "),e("div",{staticStyle:{"text-align":"center"}},[t._v("![组合选择器](20181118A/002.png)")]),t._v(" "),e("h4",{attrs:{id:"③-属性选择器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#③-属性选择器","aria-hidden":"true"}},[t._v("#")]),t._v(" ③ 属性选择器")]),t._v(" "),e("div",{staticStyle:{"text-align":"center"}},[t._v("![属性选择器](20181118A/003.png)")]),t._v(" "),e("h4",{attrs:{id:"④-伪类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#④-伪类","aria-hidden":"true"}},[t._v("#")]),t._v(" ④ 伪类")]),t._v(" "),e("div",{staticStyle:{"text-align":"center"}},[t._v("![伪类](20181118A/004.png)")]),t._v(" "),e("h4",{attrs:{id:"⑤-伪元素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#⑤-伪元素","aria-hidden":"true"}},[t._v("#")]),t._v(" ⑤ 伪元素")]),t._v(" "),e("div",{staticStyle:{"text-align":"center"}},[t._v("![伪元素](20181118A/005.png)")]),t._v(" "),e("h3",{attrs:{id:"_2-选择器的优先级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-选择器的优先级","aria-hidden":"true"}},[t._v("#")]),t._v(" (2) 选择器的优先级")]),t._v(" "),e("p",[t._v("选择器的优先级遵循一下几个原则：")]),t._v(" "),e("ol",[e("li",[t._v("选择器越具体优先级越高")]),t._v(" "),e("li",[t._v("相同优先级，写在后面的选择器会覆盖前面的选择器")]),t._v(" "),e("li",[t._v("important优先级最高，但一般不用")])]),t._v(" "),e("p",[t._v("具体来说，各选择器的级别是这样排列的：")]),t._v(" "),e("ol",[e("li",[t._v("在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。")]),t._v(" "),e("li",[t._v("作为style属性写在元素内的样式")]),t._v(" "),e("li",[t._v("id选择器")]),t._v(" "),e("li",[t._v("类选择器")]),t._v(" "),e("li",[t._v("标签选择器")]),t._v(" "),e("li",[t._v("通配符选择器（*）")]),t._v(" "),e("li",[t._v("浏览器自定义或继承")])]),t._v(" "),e("h2",{attrs:{id:"_5、bfc是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5、bfc是什么？","aria-hidden":"true"}},[t._v("#")]),t._v(" 5、BFC是什么？")]),t._v(" "),e("p",[t._v("BFC（Block Formatting Context）即“块级格式化上下文”，BFC是W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，BFC提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。也可以说BFC就是一个作用范围。")]),t._v(" "),e("p",[t._v("之前写过一篇关于BFC的博客："),e("a",{attrs:{href:"http://franko.top/1810/20181016A/",target:"_blank",rel:"noopener noreferrer"}},[t._v("【归纳】BFC解惑"),e("OutboundLink")],1),t._v("，这里就不赘述了。关于BFC的面试回答主要也是要侧重在作用方面，因为概念上的东西说不清楚，下面是两个例子：")]),t._v(" "),e("ul",[e("li",[t._v("overflow:hidden 清除浮动。（用 .clearfix 清除浮动更好）")]),t._v(" "),e("li",[t._v("overflow:hidden 取消父子 margin 合并。http://jsbin.com/conulod/1/edit?html,css,js,output （设置 padding-top: 1px;也可以达到相同效果）")])]),t._v(" "),e("h2",{attrs:{id:"_6、如何清除浮动？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6、如何清除浮动？","aria-hidden":"true"}},[t._v("#")]),t._v(" 6、如何清除浮动？")]),t._v(" "),e("p",[t._v("这里就说两种清除浮动的方法，已经足够回答面试了：")]),t._v(" "),e("h3",{attrs:{id:"overflow-hidden"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#overflow-hidden","aria-hidden":"true"}},[t._v("#")]),t._v(" overflow:hidden")]),t._v(" "),e("p",[t._v("借助BFC的特性清除浮动，但是不推荐使用。")]),t._v(" "),e("h3",{attrs:{id:"clearfix-清除浮动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#clearfix-清除浮动","aria-hidden":"true"}},[t._v("#")]),t._v(" .clearfix 清除浮动")]),t._v(" "),e("p",[t._v(".clearfix 清除浮动的代码如下：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(".clearfix::after{\n  content:'';\n  display:block;\n  clear:both;\n}\n/*兼容IE*/\n.clearfix{\n  zoom:1;\n}\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br")])]),e("hr"),t._v(" "),e("p",[t._v("编辑完成于 2018年11月19日")]),t._v(" "),e("p",[t._v("上面就是关于CSS押题的部分，这下就显示了之前写过一些博客的用处，虽然谈不上写了博客就一定完全掌握，但是还是可以让自己不至于捉襟见肘。本来昨晚打算就完成的，还是搞到了第二天才真正完成。看来以后还是要抓紧时间了。")]),e("div",{staticStyle:{"text-align":"center"}},[e("img",{attrs:{src:"20181118A/006.jpg",alt:"钟表"}})]),e("p")])},[],!1,null,null,null);a.default=s.exports}}]);