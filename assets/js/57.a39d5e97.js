(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{367:function(t,e,a){"use strict";a.r(e);var v=a(40),_=Object(v.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"tip custom-block"},[a("p",[t._v("今天下午开始把这篇系统课最后一篇博客写完，本来想先把自己的node.js服务做完，但是有点没有头绪。")])]),t._v(" "),a("p",[t._v("为了让自己情绪先稳定下来，还是先把 Web 性能优化这篇博客完成了比较好，内容不是很多，主要还是从笔记里面整理出来的。争取两小时之内把这篇博客写完，最近的效率都不太高了。")]),a("div",{staticStyle:{"text-align":"center"}},[a("img",{attrs:{src:"20181201A/timg.jfif",alt:"玩手机"}})]),a("p"),t._v(" "),a("h2",{attrs:{id:"web-性能优化分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web-性能优化分析","aria-hidden":"true"}},[t._v("#")]),t._v(" Web 性能优化分析")]),t._v(" "),a("p",[t._v("Web性能优化，咋一听还以为是比较高端的名词，如果之前从来没听过这个词语可能还真会被它唬住，比如我。实际上 Web 性能优化就是通过各种手段让页面加载变快、让用户觉得体验很好，就是要达到这个目的。听起来很浅显，实际上这件事情却有并不简单。让服务器的 CPU 使用少算是 Web 性能优化吗？这是服务器性能优化。那么怎样做才算是做到 Web 性能优化呢？")]),t._v(" "),a("p",[t._v("来简要地分析一下，从用户输入url并按下回车，到网页呈现在用户面前，经历了哪些与前端相关的过程：")]),t._v(" "),a("ul",[a("li",[t._v("首先浏览器查询缓存，如果有可以用的缓存就直接从缓存里直接读取资源")]),t._v(" "),a("li",[t._v("DNS 查询，将请求的网址变成IP地址进行查询")]),t._v(" "),a("li",[t._v("建立TCP连接，三次握手，四次挥手等等")]),t._v(" "),a("li",[t._v("浏览器发送HTTP请求，后台处理请求")]),t._v(" "),a("li",[t._v("浏览器接收响应")]),t._v(" "),a("li",[t._v("接收完成")]),t._v(" "),a("li",[t._v("开始解析HTML，查看 DOCTYPE")]),t._v(" "),a("li",[t._v("对HTML内容进行逐条解析")]),t._v(" "),a("li",[t._v("渲染CSS、HTML、JS")])]),t._v(" "),a("p",[t._v("其中最后一步「渲染CSS、HTML、JS」这里详细地讲一下。浏览器拿到HTML的内容后开始逐条解析。解析的过程大致是怎样的呢？打个比方，浏览器遇到了一个"),a("code",[t._v("<h1>")]),t._v("标签，浏览器会怎么做？")]),t._v(" "),a("p",[t._v("这个问题的答案与浏览器相关。如果是IE浏览器会直接将其渲染到页面上。如果是Chrome浏览器，则会等到所有的页面中所有引用的CSS都下载完毕，之后才会开始渲染。如果拿到一个标签就立即把它渲染到页面上，之后再取得与这个标签相关的CSS内容的话，就要把这个标签再渲染一遍。所以在Chrome浏览器中，CSS是会阻塞HTML的渲染的。")]),a("div",{staticStyle:{"text-align":"center"}},[a("img",{attrs:{src:"20181201A/001.jfif",alt:"Chrome浏览器"}})]),a("p"),t._v(" "),a("p",[t._v("当浏览器解析到页面中的外部引用的CSS之后，会同时做两件事：下载CSS，并继续查找其他的CSS。如果查找到第二个了就同时下载这个CSS。在Chrome中最多可以同时下载8个，IE中为4个。")]),t._v(" "),a("p",[t._v("JS与CSS相似，当浏览器解析到"),a("code",[t._v("<script>")]),t._v("标签后，如果是外部引用的JS，就会先将JS的内容先下载完毕。同时浏览器会先将"),a("code",[t._v("<script>")]),t._v("标签中的内容执行完毕之后才会继续解析后面得HTML标签。")]),t._v(" "),a("h2",{attrs:{id:"web-性能优化的对策"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web-性能优化的对策","aria-hidden":"true"}},[t._v("#")]),t._v(" Web 性能优化的对策")]),t._v(" "),a("p",[t._v("下面就对每一步都进行分析，看看可以从哪里入手，实现 Web 性能优化的目的。")]),a("div",{staticStyle:{"text-align":"center"}},[a("img",{attrs:{src:"20181201A/002.jpg",alt:"对策"}})]),a("p"),t._v(" "),a("h3",{attrs:{id:"dns查询的优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dns查询的优化","aria-hidden":"true"}},[t._v("#")]),t._v(" DNS查询的优化")]),t._v(" "),a("p",[t._v("每次对一个网站进行请求，就要进行一次 DNS 查询。所以可以通过减少 DNS 查询在这一步实现优化。比如需要向两个网站请求资源，那么就尽量把所有的资源放在一个网站，通过减少域名达到减少DNS查询时间的效果。")]),t._v(" "),a("h3",{attrs:{id:"建立tcp连接的优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#建立tcp连接的优化","aria-hidden":"true"}},[t._v("#")]),t._v(" 建立TCP连接的优化")]),t._v(" "),a("p",[t._v("在HTTP协议中，加上keep-alive请求头，服务器就会尽量复用这个TCP连接，这叫做连接复用。如果使用了HTTP 2.0，服用率将会更高，这种复用被称为多路复用。")]),t._v(" "),a("h3",{attrs:{id:"发送请求的优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#发送请求的优化","aria-hidden":"true"}},[t._v("#")]),t._v(" 发送请求的优化")]),t._v(" "),a("p",[t._v("知道，请求有四部分。其中请求头是可以优化的。下面提供了几种关于发送请求的优化。")]),t._v(" "),a("p",[t._v("减少Cookie的体积，不滥用Cookie。使用没有Cookie的域名提供CSS、JS，比如CDN。")]),t._v(" "),a("p",[t._v("在页面中避免写出空src的标签，因为这样会向一个空域名发送一个不必要的请求。")]),t._v(" "),a("p",[t._v("使用Cache-Control可以做到直接不发送请求，而是直接使用缓存中的内容。这是非常重要的优化手段，因为它最大效率地优化了发送请求这一步，，即直接跳过了这一步。关于Cache-Control的内容昨天我写了一篇博客，可以直接查阅前一篇博客："),a("a",{attrs:{href:"http://franko.top/1811/20181130A/",target:"_blank",rel:"noopener noreferrer"}},[t._v("【归纳】HTTP缓存相关知识"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("同时发送多个请求，让浏览器在请求CSS与JS的之后同时下载多个CSS与JS。在前面讲过，同时下载的文件数量是有上限的，如果想要同时请求更多的文件，就要增加请求的域名的数量。不过这一点与刚才讲的DNS查询优化中的减少域名互相矛盾了。")]),t._v(" "),a("p",[t._v("所以需要在其中做一个权衡。如果我的请求的文件很少，就将这些文件放到一个域名中请求，减少了DNS查询时间；如果我要请求的文件很多，这时候可以将这些文件放到多个域名下进行请求，增加了请求并发数，减少了请求时间。")]),t._v(" "),a("h3",{attrs:{id:"接收响应的优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接收响应的优化","aria-hidden":"true"}},[t._v("#")]),t._v(" 接收响应的优化")]),t._v(" "),a("p",[t._v("接收响应的优化方法主要是减少响应体的体积，这里有两种方法。")]),t._v(" "),a("p",[t._v("使用ETag消息头。这个内容我在昨天的博客中也是讲到过的。服务器可以通过浏览器请求头中的MD5字符串来判断浏览器缓存中的文件是否是最新的，如果仍然是最新版本，服务器就直接返回304状态码，告知浏览器可以继续使用缓存内容。这样就大大减少了响应的体积。")]),t._v(" "),a("p",[t._v("使用Gzip压缩文件。服务器把浏览器请求的文件用Gzip压缩之后，把这个压缩包给响应给浏览器，从而大大减少响应体积，浏览器下载文件的时间也大大加快。这种方法几乎所有网站都会使用。浏览器在接收到含有"),a("code",[t._v("Content-Encoding : gzip")]),t._v("的响应头就会尝试将响应体进行解压。因为解压也需要时间，而且解压会耗费浏览器的CPU，所以在是否需要压缩文件这一点上也是需要权衡的。")]),t._v(" "),a("h3",{attrs:{id:"doctype的优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#doctype的优化","aria-hidden":"true"}},[t._v("#")]),t._v(" DOCTYPE的优化")]),t._v(" "),a("p",[t._v("这一点比较奇怪，明明 DOCTYPE 只是一句简单的声明而已，这有什么好优化的。事实上正是因为这样忽略 DOCTYPE ，才给了这个步骤带来了优化空间。不能写错或者是不写 DOCTYPE 声明， DOCTYPE 声明可以告诉浏览器以什么样的格式对页面进行解析，如果不写 DOCTYPE 声明，浏览器会使用多种格式对页面进行预读，这是完全没必要的。")]),t._v(" "),a("h3",{attrs:{id:"为什么要使用cdn？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用cdn？","aria-hidden":"true"}},[t._v("#")]),t._v(" 为什么要使用CDN？")]),t._v(" "),a("p",[t._v("CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。")]),t._v(" "),a("p",[t._v("那么使用CDN对Web性能优化有什么好处呢？通过使用CDN提供的链接，使用了新的域名，这样就可以增加并发下载的数量，减少了的下载的时间；此外，如果是请求距离遥远的外国网站的资源，如果这份资源具有在本国的CDN链接，那么请求的时间就可以大大减少；同时CDN还可以起到减少Cookie的作用，因为CDN的服务器不会给浏览器响应含有Cookie的内容。")]),t._v(" "),a("h3",{attrs:{id:"css与js的放置位置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css与js的放置位置","aria-hidden":"true"}},[t._v("#")]),t._v(" CSS与JS的放置位置")]),t._v(" "),a("p",[t._v("之前在学写页面的时候，都是把CSS放到"),a("code",[t._v("<header>")]),t._v("里，把JS放在"),a("code",[t._v("<body>")]),t._v("的最后，但是为什么要这样做却不是很清楚。在前文说过，CSS与JS都会阻塞页面的渲染，所以需要将CSS的内容放在页面的前面提早下载，以防止其阻塞页面加载。")]),t._v(" "),a("p",[t._v("至于为什么JS放在后面，这样做首先不会让JS阻塞页面渲染，可以让用户在JS加载完成之前就可以先看到一个完整的页面，等到用户准备与页面交互时，JS也基本加载完毕了。除此之外，这样做还可以使得JS在执行的时候可以获取到页面上所有的节点，这是非常重要的。")]),t._v(" "),a("h3",{attrs:{id:"懒加载与预加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#懒加载与预加载","aria-hidden":"true"}},[t._v("#")]),t._v(" 懒加载与预加载")]),t._v(" "),a("p",[t._v("在外面加载页面时，可以先加载第一屏给用户看，等到用户将页面往下滚动时，再去加载页面后面的内容，这叫做懒加载。借助懒加载可以将页面分成几次呈现给用户，自然就能够让用户感觉到加载速度变快。加载完第一屏之后，用户还没查看第二屏时就提前加载，就叫做预加载。")]),t._v(" "),a("p",[t._v("二者都是通过巧妙的方式「欺骗」了用户，虽然页面整体的加载时间不见得就减少了，但是仍然达到了Web性能优化的效果。此外在加载过程中添加一个loading动画，也可以给让用户觉得等待时间并没有那么长。")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("上面大概就是本次博客中关于Web性能优化的内容。昨天以及预先把关于Cache-Control、ETag的内容写为博客了，这些内容也是Web性能优化的部分，也算是有所准备了总的来说，这一次我没有去针对每个点都去查阅资料，只是大致将课上讲的笔记内容在这里又叙述了一遍。因为这些内容主要是一些Web性能优化的技巧，倒也不是什么知识难点之类的。不过也因为没有去多方查阅资料的原因，很多地方可能叙述的都不够严谨，敬请谅解。")]),a("div",{staticStyle:{"text-align":"center"}},[a("img",{attrs:{src:"20181201A/003.jpg",alt:"夕阳"}})]),a("p")])},[],!1,null,null,null);e.default=_.exports}}]);