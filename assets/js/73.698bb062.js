(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{382:function(t,e,r){"use strict";r.r(e);var a=r(40),o=Object(a.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("div",{staticClass:"tip custom-block"},[r("p",[t._v("今天继续写一篇关于押题的博客，主要是关于 HTTP 的。虽然这其中的知识点有点多，但是我看基本都在之前的博客里面归纳过，所以干脆直接就把这次的押题博客写一下，大概就是把之前的博客里面的内容再针对这些知识重新归纳一下。")])]),t._v(" "),r("p",[t._v("今天是 2018 年的最后一天，昨天下了一天的雪，和大家玩了一天，没有写博客。所以这个月之内完成 20 篇博客的计划应该是完不成了，今天我就尽力写几篇吧。")]),r("div",{staticStyle:{"text-align":"center"}},[r("img",{attrs:{src:"20181231A/timg.jpg",alt:"尽头"}})]),r("p"),t._v(" "),r("h2",{attrs:{id:"_1、http-状态码知道哪些？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、http-状态码知道哪些？","aria-hidden":"true"}},[t._v("#")]),t._v(" 1、HTTP 状态码知道哪些？")]),t._v(" "),r("p",[t._v("这道题是一道很经典的题目，也没什么技巧，只要记住足够多的状态码就可以了，在系统课期中考试的时候也是考过的。这里我就把之前的答案搬运到我以前的这篇博客里：《"),r("a",{attrs:{href:"http://franko.top/1809/20180907A/#%E4%B8%89%E3%80%81HTTP-%E7%8A%B6%E6%80%81%E7%A0%81",target:"_blank",rel:"noopener noreferrer"}},[t._v("【记录】HTTP入门学习"),r("OutboundLink")],1),t._v("》，大概写了十几条状态码，面试前还是要记一记，应该是够用了。")]),t._v(" "),r("h2",{attrs:{id:"_2、301-和-302-的区别是什么？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、301-和-302-的区别是什么？","aria-hidden":"true"}},[t._v("#")]),t._v(" 2、301 和 302 的区别是什么？")]),t._v(" "),r("p",[t._v("这道题属于前一题的拓展，再来看看这两个状态码是干什么的：")]),t._v(" "),r("pre",[r("code",[t._v("状态码301：被请求的资源已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。\n状态码302：请求的资源临时从不同的URI响应请求，但请求者应继续使用原有位置来进行以后的请求。\n")])]),t._v(" "),r("p",[t._v("简单地说，301 是被请求的资源永久重定向，这个响应是看一被浏览器缓存的；而 302 是被请求的资源临时重定向，由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。")]),t._v(" "),r("h2",{attrs:{id:"_3、http-缓存怎么做？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、http-缓存怎么做？","aria-hidden":"true"}},[t._v("#")]),t._v(" 3、HTTP 缓存怎么做？")]),t._v(" "),r("p",[t._v("这道题需要回答到两个点，这两个点在之前的博客里都有提到：《"),r("a",{attrs:{href:"http://franko.top/1811/20181130A/#%E4%BD%BF%E7%94%A8Cache-Control",target:"_blank",rel:"noopener noreferrer"}},[t._v("【归纳】HTTP缓存相关知识"),r("OutboundLink")],1),t._v("》：")]),t._v(" "),r("ol",[r("li",[t._v("在 Cache-Control 响应头设置缓存有效时间： "),r("code",[t._v("response.setHeader('Cache-control','max-age = 30')")])]),t._v(" "),r("li",[t._v("在请求路径的 url 上添加查询参数避开缓存，如："),r("code",[t._v('<link rel="stylesheet" href="./css/default.css?v=2">')])])]),t._v(" "),r("h2",{attrs:{id:"_4、cache-control-和-etag-的区别是什么？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4、cache-control-和-etag-的区别是什么？","aria-hidden":"true"}},[t._v("#")]),t._v(" 4、Cache-Control 和 Etag 的区别是什么？")]),t._v(" "),r("p",[t._v("这道题的答案涉及到的也是之前的系统课里讲过的知识点了，所以在以前的博客里都有所涉及：《"),r("a",{attrs:{href:"http://franko.top/1811/20181130A/#%E4%BD%BF%E7%94%A8ETag",target:"_blank",rel:"noopener noreferrer"}},[t._v("【归纳】HTTP缓存相关知识"),r("OutboundLink")],1),t._v("》，看来复习博客还是比较重要的。")]),t._v(" "),r("p",[t._v("简单地说，使用Cache-Control响应头后，在缓存有效期内，直接不会再对相同内容发起请求；使用ETag响应头仍然会发起请求，如果接受到304状态码，就不会在下载相关内容。")]),t._v(" "),r("h2",{attrs:{id:"_5、cookie-是什么？session-是什么？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5、cookie-是什么？session-是什么？","aria-hidden":"true"}},[t._v("#")]),t._v(" 5、Cookie 是什么？Session 是什么？")]),t._v(" "),r("p",[t._v("关于 Cookie 和 Session，我分别写了两篇博客来归纳它们的相关知识点：《"),r("a",{attrs:{href:"http://franko.top/1811/20181113A/",target:"_blank",rel:"noopener noreferrer"}},[t._v("【记录】登录注册与Cookie"),r("OutboundLink")],1),t._v("》、《"),r("a",{attrs:{href:"http://franko.top/1811/20181124A/",target:"_blank",rel:"noopener noreferrer"}},[t._v("【归纳】Session相关知识"),r("OutboundLink")],1),t._v("》。里面讲的还算比较详细，这里的话就简单地讲一下好了：")]),t._v(" "),r("ul",[r("li",[t._v("Cookie\n"),r("ol",[r("li",[t._v("HTTP 响应通过 Set-Cookie 设置 Cookie")]),t._v(" "),r("li",[t._v("浏览器访问指定域名是必须带上 Cookie 作为 Request Header")]),t._v(" "),r("li",[t._v("Cookie 一般用来记录用户信息")])])]),t._v(" "),r("li",[t._v("Session\n"),r("ol",[r("li",[t._v("Session 是服务器端的内存（数据）")]),t._v(" "),r("li",[t._v("Session 一般通过在 Cookie 里记录 SessionID 实现")]),t._v(" "),r("li",[t._v("SessionID 一般是随机数")])])])]),t._v(" "),r("h2",{attrs:{id:"_6、localstorage-和-cookie-的区别是什么？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6、localstorage-和-cookie-的区别是什么？","aria-hidden":"true"}},[t._v("#")]),t._v(" 6、LocalStorage 和 Cookie 的区别是什么？")]),t._v(" "),r("p",[t._v("LocalStorage 的知识点我也是写过一篇博客来归纳过的。里面对于二者的区别也讲得比较详细：《"),r("a",{attrs:{href:"http://franko.top/1811/20181126A/#LocalStorage%E7%9A%84%E7%89%B9%E7%82%B9",target:"_blank",rel:"noopener noreferrer"}},[t._v("【归纳】LocalStorage是什么"),r("OutboundLink")],1),t._v("》，这里简单地提一下：")]),t._v(" "),r("ol",[r("li",[t._v("Cookie 会随请求被发到服务器上，而 LocalStorage 不会")]),t._v(" "),r("li",[t._v("Cookie 大小一般4k以下，LocalStorage 一般5Mb 左右")])]),t._v(" "),r("h2",{attrs:{id:"_7、（必考）http的常用方法，以及它们的区别是什么？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7、（必考）http的常用方法，以及它们的区别是什么？","aria-hidden":"true"}},[t._v("#")]),t._v(" 7、（必考）HTTP的常用方法，以及它们的区别是什么？")]),t._v(" "),r("p",[t._v("HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。")]),t._v(" "),r("p",[t._v("HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。")]),t._v(" "),r("h3",{attrs:{id:"get-和-post"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#get-和-post","aria-hidden":"true"}},[t._v("#")]),t._v(" GET 和 POST")]),t._v(" "),r("p",[t._v("GET 和 POST 都是请求的类型，分别代表「获取」与「新增」。如果面试问到二者的区别，主要可以通过如下角度回答：")]),t._v(" "),r("ol",[r("li",[t._v("参数。GET 的参数放在 url 的查询参数里，POST 的参数（数据）放在请求消息体里。Post相对Get相对安全一些，因为Get请求都包含在URL中，而且会被浏览器保存记录，Post不会。但是再抓包的情况下都是一样的。")]),t._v(" "),r("li",[t._v("GET 没有 POST 安全（其实都不安全）")]),t._v(" "),r("li",[t._v("GET 的参数（url查询参数）有长度限制，一般是 1024 个字符。POST 的参数（数据）没有长度限制（其实有4~10Mb 限制），URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的。Post 可以通过 request body来传输比 Get 更多的数据")]),t._v(" "),r("li",[t._v("GET 请求只需要发一个包，POST 请求需要发两个以上包（因为 POST 有消息体）")]),t._v(" "),r("li",[t._v("GET 用来读数据，POST 用来写数据。")])]),t._v(" "),r("h3",{attrs:{id:"put和post"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#put和post","aria-hidden":"true"}},[t._v("#")]),t._v(" PUT和POST")]),t._v(" "),r("p",[t._v("PUT 和 POST 都有更改指定URI的语义.但 PUT 被定义为幂等的方法，POST 则不是幂等的方法:如果一个方法重复执行多次，产生的效果是一样的，那就是 idempotent 的。也就是说：")]),t._v(" "),r("p",[t._v("PUT 请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以 PUT 用来改资源）")]),t._v(" "),r("p",[t._v("POST 请求：后一个请求不会把第一个请求覆盖掉。（所以 POST 用来增资源）")]),t._v(" "),r("p",[t._v("在编程中.一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同，即无其他副作用。")]),t._v(" "),r("h2",{attrs:{id:"_8、（必考）怎么跨域？jsonp-是什么？cors-是什么？postmessage-是什么？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8、（必考）怎么跨域？jsonp-是什么？cors-是什么？postmessage-是什么？","aria-hidden":"true"}},[t._v("#")]),t._v(" 8、（必考）怎么跨域？JSONP 是什么？CORS 是什么？postMessage 是什么？")]),t._v(" "),r("p",[t._v("实现跨域的方法主要有这三种，JSONP、CORS、postMessage。其中 JSONP 与 CORS 我在之前的博客里都提到过：《"),r("a",{attrs:{href:"http://franko.top/1811/20181111A/",target:"_blank",rel:"noopener noreferrer"}},[t._v("【归纳】认识JSONP"),r("OutboundLink")],1),t._v("》、《"),r("a",{attrs:{href:"http://franko.top/1811/20181115A/#AJAX%E4%B8%8E%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96",target:"_blank",rel:"noopener noreferrer"}},[t._v("【归纳】AJAX是什么"),r("OutboundLink")],1),t._v("》。postMessage 倒是之前没什么了解，可以在 MDN 临时学习一下："),r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage",target:"_blank",rel:"noopener noreferrer"}},[t._v("window.postMessage | MDN"),r("OutboundLink")],1),t._v("。这里就对三者简单概括一下：")]),t._v(" "),r("pre",[r("code",[t._v("JSONP：动态创建 <script> 标签以规避同源策略\nCORS：服务器在响应头中添加Access-Control-Allow-Origin字段，设置允许跨域请求的域名。\npostMessage：window.postMessage 的功能是允许程序员跨域在两个窗口/ frames 间发送数据信息。基本上，它就像是跨域的 AJAX，但不是浏览器跟服务器之间交互，而是在两个客户端之间通信。\n")])]),t._v(" "),r("hr"),t._v(" "),r("p",[t._v("以上就是本篇博客关于 HTTP 押题的所有内容。可以发现，很多内容都是以前博客里写过的，所以这博客写起来豆业不怎么费力。虽然这些都不是很难的知识点，都是一些要背的内容，到面试前还是得回来再看一下的。")]),r("div",{staticStyle:{"text-align":"center"}},[r("img",{attrs:{src:"20181231A/001.jpg",alt:"请求"}})]),r("p")])},[],!1,null,null,null);e.default=o.exports}}]);