(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{385:function(t,s,a){"use strict";a.r(s);var n=a(40),r=Object(n.a)({},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"tip custom-block"},[a("p",[t._v("今天继续开一篇博客，复习一下早之前的 JavaScript 实现排序算法的内容。和上次的内容一样，我也已经把归并排序的内容忘得一干二净了，今天晚上如果有时间的话就重新把这个知识点学习一下。")])]),t._v(" "),a("p",[t._v("这也是我这么久以来第一次，试着一天写三篇博客这样，能不能完成 12 月份的博客任务的话，就随缘了，因为时间太紧了，感觉不知道写什么了已经。")]),a("div",{staticStyle:{"text-align":"center"}},[a("img",{attrs:{src:"20181231C/timg.jpg",alt:"打字"}})]),a("p"),t._v(" "),a("p",[t._v("下面是是维基百科中关于归并排序的一些解释：")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("归并排序")]),t._v("（英语：Merge sort，或mergesort），是建立在归并操作上的一种有效的排序算法，效率为O(nlogn)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。")])]),t._v(" "),a("p",[t._v("归并排序算法依赖归并操作，那么什么是归并操作呢？归并操作（merge），指的是先将已有序的子序列合并，得到完全有序的序列的操作。即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。")]),t._v(" "),a("p",[t._v("大概讲一下归并排序的思路：")]),t._v(" "),a("ol",[a("li",[t._v("假设有一个代排数组，数组长度为n。首先将数组一分为二，两个数组的长度均为 n / 2。")]),t._v(" "),a("li",[t._v("再对两个子数组进行切分，当珠海没管子数组被分到长度为2，数组的切分操作就完成了。")]),t._v(" "),a("li",[t._v("开始归并操作，将切分自同一数组的子数组进行比较，设定两个指针，最初位置分别为两个已经排序序列的起始位置。")]),t._v(" "),a("li",[t._v("然后比较两个指针所指向的元素，选择相对小的元素放入到准备好的空数组中，并移动指针到下一位置。")]),t._v(" "),a("li",[t._v("这样两个子数组最终就会被有序地合并到一个数组中，同样地对其他子数组也进行上述操作。")]),t._v(" "),a("li",[t._v("最终整个数组会被归并到同一个有序的数组中。")])]),t._v(" "),a("p",[t._v("来看一下归并排序的动图，比我上面的描述更加容易理解：")]),a("div",{staticStyle:{"text-align":"center"}},[a("img",{attrs:{src:"20181231C/001.gif",alt:"归并排序1"}})]),a("p"),t._v(" "),a("p",[t._v("以下是 JavaScript 版本的的代码实现：")]),t._v(" "),a("div",{staticClass:"language-JavaScript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("mergeSort")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("arr")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" arr\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" mid "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" arr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("merge")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("left"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" right")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" result "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("left"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" right"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      result"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("left"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" right"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" left"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("shift")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" right"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("shift")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" result"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("concat")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("left"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("concat")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("right"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("merge")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("mergeSort")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("slice")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" mid"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("mergeSort")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("slice")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("mid"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br"),a("span",{staticClass:"line-number"},[t._v("16")]),a("br")])]),a("p",[t._v("整个代码不长，其中的操作却比较繁杂，是一个函数套函数的结构，大致分析一下上面的代码。")]),t._v(" "),a("ol",[a("li",[t._v("首先要传入一个待排数组进入 mergeSort 函数里，这个数组首先长度要不小于 2，否则直接返回原数组。")]),t._v(" "),a("li",[t._v("此外 mergeSort 函数中还定义了两个值，数组中值与函数 merge。其中数组中值的作用是把数据切分为两部分，merge 函数是一个排序操作的函数。")]),t._v(" "),a("li",[t._v("mergeSort 函数的返回值是一个 merge 函数的返回值，merge 函数接受 left 与 right 两个数组参数，因此数组会被一直切分直到长度小于 2。")]),t._v(" "),a("li",[t._v("merge 函数的排序操作是比较 left[0] 与 right[0] 两个数组的大小，较小值弹出数组到设定好的准备好的空数组 result 中。")]),t._v(" "),a("li",[t._v("最终 merge 函数的返回值就是 left 与 right 两数组的排序结果，就是 result 数组再连接上 left 与 right 中剩下的最大值。")]),t._v(" "),a("li",[t._v("这个返回值又将参与下一轮的归并排序，重复这个操作，直到整个排序完成，函数输出的结果就是排序结果。")])]),t._v(" "),a("p",[t._v("虽然看起来有点绕，但是逻辑还是比较清晰的，就是一个先切分再排序的过程，再放一张标明了排序时指针位置的动图：")]),a("div",{staticStyle:{"text-align":"center"}},[a("img",{attrs:{src:"20181231C/002.gif",alt:"归并排序2"}})]),a("p"),t._v(" "),a("p",[t._v("再来看看代码的执行效果，事实证明代码是可以正常实现排序功能的： ")]),a("div",{staticStyle:{"text-align":"center"}},[a("img",{attrs:{src:"20181231C/003.png",alt:"截图"}})]),a("p"),t._v(" "),a("p",[t._v("归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn）的时间复杂度。代价是需要额外的内存空间。")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("以上就是本篇博客中关于归并排序的所有内容。归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。要说缺点，应该就是比较占用内存了吧，毕竟每次都要使用空间存放左、右数组，以及存放结果的数组。")]),a("div",{staticStyle:{"text-align":"center"}},[a("img",{attrs:{src:"20181231C/004.jpg",alt:"跨年"}})]),a("p"),t._v(" "),a("p",[t._v("这个月的博客数量锁定在 19 篇了，总感觉有点遗憾吧，因为这个月时间浪费得有点多，只要稍微多一点点的时间，就能够多整理一篇博客，凑够 20 篇了。难道这是在预示 2019年的到来吗？这几天天天写博客把很多我想写的内容都写掉了，之前因为没写博客总是有些郁闷，现在心里也像是了解一桩心事一般舒坦。倒是有点不知道一月份还有什么东西可写了，不过到时候肯定又学了新东西嘛。2018 年就只剩下几十分钟了，这篇博客也将是 2018 年的最后一篇博客，希望在 2019 年我能顺利学习完所有我计划学习的知识，找到一份好工作吧。最后祝我自己新年快乐。")])])},[],!1,null,null,null);s.default=r.exports}}]);