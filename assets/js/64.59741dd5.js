(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{374:function(t,a,e){"use strict";e.r(a);var s=e(40),r=Object(s.a)({},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("div",{staticClass:"tip custom-block"},[e("p",[t._v("这篇博客接续上篇"),e("a",{attrs:{href:"http://franko.top/1812/20181211A/",target:"_blank",rel:"noopener noreferrer"}},[t._v("【归纳】JS中的正则对象"),e("OutboundLink")],1),t._v("中的内容，主要是对正则表达式的一些基础规则进行归纳。")])]),t._v(" "),e("p",[t._v("本来是想在昨晚将正则表达式的内容都归纳到一篇博客里的，但是因为写在一起可能会造成篇幅过长，而且归纳不清楚，所以这里干脆新开一篇博客来好好归纳正则表达式的相关知识。")]),e("div",{staticStyle:{"text-align":"center"}},[e("img",{attrs:{src:"20181217A/timg.jpg",alt:"正则"}})]),e("p"),t._v(" "),e("p",[e("em",[t._v("写在 ‎2018‎-‎12‎-‎11‎ ‏‎21:43:18 的前言")])]),t._v(" "),e("p",[t._v("本篇博客的计划是把正则表达式的相关知识写一下，结果头还没起好又停电了，现在只能写一步看一步了。正则表达式的相关知识其实还是蛮重要的，但是在系统课上老师一直蓄着没讲，希望自己去学习。在网易云音乐毕设中也算是初步见识到了正则表达式的厉害，借助这个功能，筛选出了歌词字符串中的时间内容与歌词内容。但是仅仅使用过这一次还远远不够算是学会使用正则表达式，所以在前一段时间我看了一节关于正则表达式的视频，也做了些笔记。今晚没啥好写的，就干脆把之前的笔记整理一下，也算是复习吧。")]),t._v(" "),e("h2",{attrs:{id:"一、编写模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、编写模式","aria-hidden":"true"}},[t._v("#")]),t._v(" 一、编写模式")]),t._v(" "),e("p",[t._v("一个正则表达式模式是由简单的字符所构成的，比如 "),e("code",[t._v("/abc/")]),t._v("，或者是简单和特殊字符的组合，比如 "),e("code",[t._v("/ab*c/")]),t._v("。来看看这两种编写模式有何不同。")]),t._v(" "),e("h3",{attrs:{id:"_1、使用简单的模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、使用简单的模式","aria-hidden":"true"}},[t._v("#")]),t._v(" 1、使用简单的模式")]),t._v(" "),e("p",[t._v("简单的模式是由你找到的直接匹配所构成的。比如，/abc/这个模式就匹配了在一个字符串中，仅仅字符 "),e("code",[t._v("'abc'")]),t._v(" 同时出现并按照这个顺序。在 "),e("code",[t._v('"Hi, do you know your abc\'s?"')]),t._v(" 和 "),e("code",[t._v('"The latest airplane designs evolved from slabcraft."')]),t._v(" 就会匹配成功。在上面的两个实例中，匹配的是子字符串 "),e("code",[t._v("'abc'")]),t._v("。在字符串 "),e("code",[t._v('"Grab crab"')]),t._v(" 中将不会被匹配，因为它不包含任何的 "),e("code",[t._v("'abc'")]),t._v(" 子字符串。")]),t._v(" "),e("h3",{attrs:{id:"_2、使用特殊字符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、使用特殊字符","aria-hidden":"true"}},[t._v("#")]),t._v(" 2、使用特殊字符")]),t._v(" "),e("p",[t._v("当你需要搜索一个比直接匹配需要更多条件的匹配时，比如寻找一个或多个 'b'，或者寻找空格，那么这时模式将要包含特殊字符。比如， 模式 "),e("code",[t._v("/ab*c/")]),t._v(" 匹配了一个单独的 'a' 后面跟了零个或者多个 'b'（ "),e("code",[t._v("*")]),t._v(' 的意思是前面一项出现了零个或者多个），且后面跟着 \'c\' 的任何字符组合。在字符串 "cbbabbbbcdebc" 中，这个模式匹配了子字符串 "abbbbc"。')]),t._v(" "),e("p",[t._v("下面就将正则表达式中可以利用的特殊字符进行简单的归纳。")]),t._v(" "),e("h2",{attrs:{id:"二、特殊符号"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、特殊符号","aria-hidden":"true"}},[t._v("#")]),t._v(" 二、特殊符号")]),t._v(" "),e("h3",{attrs:{id:"_1、元字符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、元字符","aria-hidden":"true"}},[t._v("#")]),t._v(" 1、元字符")]),t._v(" "),e("p",[t._v("正则表达式语言由两种基本字符类型组成：原义（正常）文本字符和元字符。元字符使正则表达式具有处理能力。所谓元字符就是指那些在正则表达式中具有特殊意义的专用字符，可以用来规定其前导字符（即位于元字符前面的字符）在目标对象中的出现模式。下面是常用的一些元字符：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("代码")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v(".")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("匹配除换行符以外的任意字符")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("\\w")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("匹配字母或数字或下划线或汉字")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("\\s")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("匹配任意的空白符")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("\\d")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("匹配数字")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("\\b")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("匹配单词的开始或结束")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("\\n")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("匹配一个换行符 (U+000A)。")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("\\r")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("匹配一个回车符 (U+000D)。")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("^")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("匹配字符串的开始")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("$")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("匹配字符串的结束")])])])]),t._v(" "),e("p",[t._v("在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前面''的'b'通常匹配小写'b'，无论它们出现在哪里。如果加了'',这个字符变成了一个特殊意义的字符，意思是匹配一个字符边界。")]),t._v(" "),e("p",[t._v("反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 "),e("code",[t._v("/a*/")]),t._v(" 代表会匹配 0 个或者多个 a。相反，模式 "),e("code",[t._v("/a\\*/")]),t._v(" 将 "),e("code",[t._v("'*'")]),t._v(' 的特殊性移除，从而可以匹配像 "a*" 这样的字符串。')]),t._v(" "),e("h3",{attrs:{id:"_2、字符类与量词"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、字符类与量词","aria-hidden":"true"}},[t._v("#")]),t._v(" 2、字符类与量词")]),t._v(" "),e("p",[t._v("要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u)，只需要在方括号里列出它们就行了，像 "),e("code",[t._v("[aeiou]")]),t._v(" 就匹配任何一个英文元音字母，"),e("code",[t._v("[.?!]")]),t._v(" 匹配标点符号(.或?或!)，方括号可以用于指定一个字符集合，匹配方括号中的任意字符。")]),t._v(" "),e("p",[t._v("也可以轻松地指定一个字符范围，像 "),e("code",[t._v("[0-9]")]),t._v(" 代表的含意与\\d就是完全一致的：一位数字；同理 "),e("code",[t._v("[a-z0-9A-Z_]")]),t._v(" 也完全等同于"),e("code",[t._v("\\w")]),t._v("（如果只考虑英文的话）。假设要使用正则表达式校验邮箱是否合法，就可以这样写：")]),t._v(" "),e("div",{staticClass:"language-JavaScript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" re "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/^[a-z0-9]+@[a-z0-9]+\\.[a-z]+$/i")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("除此之外，在正则表达式中还有许多方式指定重复的方法，下面是一些常用的限定符：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("代码")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("*")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("重复零次或更多次")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("+")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("重复一次或更多次")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("?")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("重复零次或一次")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("{n}")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("重复n次")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("{n,}")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("重复n次或更多次")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("{n,m}")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("重复n到m次")])])])]),t._v(" "),e("p",[t._v("比如，"),e("code",[t._v("/a{2}/")]),t._v("不会匹配“candy”中的'a',但是会匹配“caandy”中所有的a，以及“caaandy”中的前两个'a'。"),e("code",[t._v("/a{1, 3}/")]),t._v(" 并不匹配“cndy”中的任意字符，匹配“candy”中的a，匹配“caandy”中的前两个a，也匹配“caaaaaaandy”中的前三个a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的a。")]),t._v(" "),e("h3",{attrs:{id:"_3、反义字符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、反义字符","aria-hidden":"true"}},[t._v("#")]),t._v(" 3、反义字符")]),t._v(" "),e("p",[t._v("有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("代码")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("\\W")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("匹配任意不是字母，数字，下划线，汉字的字符")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("\\S")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("匹配任意不是空白符的字符")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("\\D")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("匹配任意非数字的字符")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("\\B")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("匹配不是单词开头或结束的位置")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("[^x]")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("匹配除了x以外的任意字符")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("[^aeiou]")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("匹配除了aeiou这几个字母以外的任意字符")])])])]),t._v(" "),e("p",[t._v("例如，"),e("code",[t._v("\\S+")]),t._v("匹配不包含空白符的字符串。"),e("code",[t._v("<a[^>]+>")]),t._v("匹配用尖括号括起来的以a开头的字符串。")]),t._v(" "),e("h3",{attrs:{id:"_4、分支字符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、分支字符","aria-hidden":"true"}},[t._v("#")]),t._v(" 4、分支字符")]),t._v(" "),e("p",[t._v("有的时候可以需要同时匹配两种相差非常大字符，，需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。在前文就提到了一个例子，"),e("code",[t._v("/北京|百度|淘宝/g")]),t._v("这条规则就可以将字符串中的「北京」或「百度」或「淘宝」筛选出来。")]),t._v(" "),e("p",[t._v("又比如，"),e("code",[t._v("\\d{5}-\\d{4}|\\d{5}")]),t._v("这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成"),e("code",[t._v("\\d{5}|\\d{5}-\\d{4}")]),t._v("的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。")]),t._v(" "),e("h2",{attrs:{id:"三、修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、修饰符","aria-hidden":"true"}},[t._v("#")]),t._v(" 三、修饰符")]),t._v(" "),e("p",[t._v("正则表达式有几个可选参数进行全局和不分大小写搜索。这些参数既可以单独使用也可以一起使用在任何顺序和包含正则表达式的部分中。这些修饰符在上一篇博客也提到过，它们分别对应正则对象的相关属性：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("代码")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("g")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("全局搜索。")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("i")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("不区分大小写搜索。")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("m")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("多行搜索。")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("y")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。")])])])]),t._v(" "),e("p",[t._v("标志是一个正则表达式的一部分，它们在接下来的时间将不能添加或删除。")]),t._v(" "),e("p",[t._v("例如，"),e("code",[t._v("re = /\\w+\\s/g")]),t._v(" 将创建一个查找一个或多个字符后有一个空格的正则表达式，或者组合起来像此要求的字符串。")]),t._v(" "),e("div",{staticClass:"language-JavaScript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" re "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/\\w+\\s/g")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" str "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"fee fi fo fum"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" myArray "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" str"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("match")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("re"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("myArray"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br")])]),e("p",[t._v('这段代码将输出 ["fee ", "fi ", "fo "]。在这个例子中，你可以将 '),e("code",[t._v("var re = /\\w+\\s/g")]),t._v(" 替换成 "),e("code",[t._v('var re = new RegExp("\\\\w+\\\\s", "g")')]),t._v(" 并且能获取到相同的结果。")]),t._v(" "),e("p",[t._v("m标志用于指定多行输入字符串应该被视为多个行。如果使用m标志，^和$匹配的开始或结束输入字符串中的每一行，而不是整个字符串的开始或结束。")]),t._v(" "),e("p",[t._v("此外，在 ES6 还新增了一种 u 修饰符,此修饰符标识能够正确处理大于\\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。比如:")]),t._v(" "),e("div",{staticClass:"language-JavaScript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[t._v("console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/^\\uD842/u")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("test")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"\\uD842\\uDFB7"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v('输出false，由于"\\uD842\\uDFB7"是一个四个字节的UTF-16编码，代表一个字符，所以如果正则表达式带有u修饰符，那么就能够识别它。')]),t._v(" "),e("div",{staticClass:"language-JavaScript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[t._v("console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/^\\uD842/")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("test")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"\\uD842\\uDFB7"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("输出true；不加u修饰符，那么就无法将四个字节的UTF-16编码识别为一个字符，所以就可以产生匹配。")]),t._v(" "),e("h2",{attrs:{id:"四、分组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、分组","aria-hidden":"true"}},[t._v("#")]),t._v(" 四、分组")]),t._v(" "),e("p",[t._v("如果想要重复多个字符，你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了。小括号被称为「捕获括号」，也是元字符的一种。例如，"),e("code",[t._v("/a(b)c/")]),t._v(" 可以匹配字符串“abc”，并将“b”填入一个分组。")]),t._v(" "),e("p",[e("code",[t._v("(\\d{1,3}\\.){3}\\d{1,3}")]),t._v("是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它："),e("code",[t._v("\\d{1,3}")]),t._v("匹配1到3位的数字，"),e("code",[t._v("(\\d{1,3}\\.){3}")]),t._v("匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字"),e("code",[t._v("(\\d{1,3})")]),t._v("。但是这种匹配方式并不完善，还需要限制 IP 地址数字的范围，所以"),e("code",[t._v("((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)")]),t._v("才能完全实现匹配。")]),t._v(" "),e("p",[t._v("下面是一些分组的一些常见语法。")]),t._v(" "),e("h3",{attrs:{id:"_1、分组引用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、分组引用","aria-hidden":"true"}},[t._v("#")]),t._v(" 1、分组引用")]),t._v(" "),e("p",[t._v("使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。")]),t._v(" "),e("p",[t._v("后向引用用于重复搜索前面某个分组匹配的文本。例如，\\1代表分组1匹配的文本。例如，"),e("code",[t._v("\\b(\\w+)\\b\\s+\\1\\b")]),t._v("可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字"),e("code",[t._v("(\\b(\\w+)\\b)")]),t._v("，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符"),e("code",[t._v("(\\s+)")]),t._v("，最后是分组1中捕获的内容（也就是前面匹配的那个单词）"),e("code",[t._v("(\\1)")]),t._v("。")]),t._v(" "),e("p",[t._v("使用括号匹配的子字符串的数量是无限的。返回的数组中保存所有被发现的子匹配。下面的例子使用replace()方法来转换字符串中的单词。在匹配到的替换文本中，使用替代的 $1、$2 表示第一个和第二个括号的子字符串匹配。")]),t._v(" "),e("div",{staticClass:"language-JavaScript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" re "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/(\\w+)\\s(\\w+)/")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" str "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"John Smith"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" newstr "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" str"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("replace")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("re"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"$2, $1"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("newstr"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v('//"Smith, John"。')]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br")])]),e("h3",{attrs:{id:"_2、分组命名"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、分组命名","aria-hidden":"true"}},[t._v("#")]),t._v(" 2、分组命名")]),t._v(" "),e("p",[t._v("你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法："),e("code",[t._v("(?<Word>\\w+)")]),t._v("(或者把尖括号换成'也行："),e("code",[t._v("(?'Word'\\w+))")]),t._v(",这样就把"),e("code",[t._v("\\w+")]),t._v("的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用"),e("code",[t._v("\\k<Word>")]),t._v(",所以上一个例子也可以写成这样："),e("code",[t._v("\\b(?<Word>\\w+)\\b\\s+\\k<Word>\\b")]),t._v("。")]),t._v(" "),e("h3",{attrs:{id:"_3、非捕获括号"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、非捕获括号","aria-hidden":"true"}},[t._v("#")]),t._v(" 3、非捕获括号")]),t._v(" "),e("p",[t._v("在形如"),e("code",[t._v("(?:x)")]),t._v("的语法中，括号被称为「非捕获括号」。这样的表达式会匹配x的内容，但不捕获匹配的文本到分组中，更不会给此分组分配组号。")]),t._v(" "),e("p",[t._v("非捕获括号能够定义与正则表达式运算符一起使用的子表达式。例如 "),e("code",[t._v("/(?:foo){1,2}/")]),t._v(" 。如果表达式是 "),e("code",[t._v("/foo{1,2}/")]),t._v("，"),e("code",[t._v("{1,2}")]),t._v("将只对 'foo' 的最后一个字符 'o' 生效。如果使用非捕获括号，则"),e("code",[t._v("{1,2}")]),t._v("会匹配整个 'foo' 单词。")]),t._v(" "),e("p",[t._v("但是事实上从上面　IP 地址的例子就可以知道，捕获括号也可以实现相同的效果。所以非捕获括号只有不给括号内容分组的功能。")]),t._v(" "),e("h3",{attrs:{id:"_4、注释"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、注释","aria-hidden":"true"}},[t._v("#")]),t._v(" 4、注释")]),t._v(" "),e("p",[t._v("小括号的另一种用途是通过语法(?#comment)来包含注释。例如：")]),t._v(" "),e("div",{staticClass:"language-JavaScript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" re "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/2[0-4]\\d(?#200-249)|25[0-5](?#250-255)|[01]?\\d\\d?(?#0-199)/")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读.")]),t._v(" "),e("h2",{attrs:{id:"五、零宽断言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五、零宽断言","aria-hidden":"true"}},[t._v("#")]),t._v(" 五、零宽断言")]),t._v(" "),e("p",[t._v("零宽断言用于查找在某些内容(但并不包括这些内容)之前或之后的东西。这个名词看起来很高深，通俗点说就是可以用于查找是否具有某些前缀或后缀的词语，但查找结果并不包括这些前缀或后缀。直接举例说明。")]),t._v(" "),e("h3",{attrs:{id:"_1、正向肯定查找"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、正向肯定查找","aria-hidden":"true"}},[t._v("#")]),t._v(" 1、正向肯定查找")]),t._v(" "),e("p",[t._v("(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。例如，"),e("code",[t._v("/Jack(?=Sprat)/")]),t._v("会匹配到后面跟着'Sprat'的'Jack'。"),e("code",[t._v("/Jack(?=Sprat|Frost)/")]),t._v("匹配后面跟着'Sprat'或者是‘Frost’的'Jack'。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。")]),t._v(" "),e("h3",{attrs:{id:"_2、负向肯定查找"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、负向肯定查找","aria-hidden":"true"}},[t._v("#")]),t._v(" 2、负向肯定查找")]),t._v(" "),e("p",[e("code",[t._v("(?<=exp)")]),t._v("也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如"),e("code",[t._v("(?<=\\bre)\\w+\\b")]),t._v("会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。")]),t._v(" "),e("h3",{attrs:{id:"_3、正向否定查找"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、正向否定查找","aria-hidden":"true"}},[t._v("#")]),t._v(" 3、正向否定查找")]),t._v(" "),e("p",[t._v("零宽度负预测先行断言"),e("code",[t._v("(?!exp)")]),t._v("，断言此位置的后面不能匹配表达式exp。例如："),e("code",[t._v("\\d{3}(?!\\d)")]),t._v("匹配三位数字，而且这三位数字的后面不能是数字；"),e("code",[t._v("\\b((?!abc)\\w)+\\b")]),t._v("匹配不包含连续字符串abc的单词。")]),t._v(" "),e("h3",{attrs:{id:"_4、负向否定查找"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、负向否定查找","aria-hidden":"true"}},[t._v("#")]),t._v(" 4、负向否定查找")]),t._v(" "),e("p",[t._v("可以用"),e("code",[t._v("(?<!exp)")]),t._v("，零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp："),e("code",[t._v("(?<![a-z])\\d{7}")]),t._v("匹配前面不是小写字母的七位数字。")]),t._v(" "),e("p",[t._v("譬如这个表达式：")]),t._v(" "),e("div",{staticClass:"language-JavaScript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" re1 "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/(?<=<(\\w+)>).*(?=<\\/\\1>)/")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("这个表达式可以将任意 html 标签中的内容提取出来，表现了零宽断言的真正用途。")]),t._v(" "),e("h2",{attrs:{id:"六、贪婪与懒惰"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#六、贪婪与懒惰","aria-hidden":"true"}},[t._v("#")]),t._v(" 六、贪婪与懒惰")]),t._v(" "),e("p",[t._v("当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例："),e("code",[t._v("a.*b")]),t._v("，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为"),e("strong",[t._v("贪婪匹配")]),t._v("。")]),t._v(" "),e("p",[t._v("有时，更需要"),e("strong",[t._v("懒惰匹配")]),t._v("，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样."),e("code",[t._v("*?")]),t._v("就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。例如，"),e("code",[t._v("a.*?b")]),t._v("匹配最短的，以a开始、以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。")]),t._v(" "),e("p",[t._v("为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权。")]),t._v(" "),e("p",[t._v("下面是一些懒惰限定符:")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("代码")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("*?")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("重复任意次，但尽可能少重复")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("+?")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("重复1次或更多次，但尽可能少重复")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("??")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("重复0次或1次，但尽可能少重复")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("{n,m}?")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("重复n到m次，但尽可能少重复")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("{n,}?")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("重复n次以上，但尽可能少重复")])])])]),t._v(" "),e("hr"),t._v(" "),e("p",[e("em",[t._v("完成于 2018-12-17 13:42:10")])]),t._v(" "),e("p",[t._v("终于把关于正则表达式的一些知识整理完了，没想到也有那么多。不过经过这两篇博客，总算可以说自己对正则不是一无所知，并且以后还可以自己用用正则了。前几天决定动笔写正则的博客的时候，一时间难以下笔，主要还是因为那个时候对正则还是处于懵懵懂懂的状态。所以本篇博客同样是边学边写的成果，主要参考资料有「"),e("a",{attrs:{href:"http://deerchao.net/tutorials/regex/regex.htm",target:"_blank",rel:"noopener noreferrer"}},[t._v("正则表达式30分钟入门教程"),e("OutboundLink")],1),t._v("」与「"),e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions",target:"_blank",rel:"noopener noreferrer"}},[t._v("正则表达式 | MDN"),e("OutboundLink")],1),t._v("」，在此感谢他们给我带来的帮助。")]),e("div",{staticStyle:{"text-align":"center"}},[e("img",{attrs:{src:"20181217A/001.jpg",alt:"懒腰"}})]),e("p")])},[],!1,null,null,null);a.default=r.exports}}]);